{
  "model": "claude-3-5-sonnet",
  "router_id": "anthropic/claude-3.5-sonnet",
  "timestamp": "2025-06-02T02:12:40.446107+00:00Z",
  "success": true,
  "durationSec": 7.11,
  "attempts": 1,
  "code": "stack(\n  // Main guitar melody with country twang\n  note(\"g3 a3 [b3 a3] g3, [~ e4] [d4 b3] a3 g3\")\n  .s(\"gm_acoustic_guitar_steel\")\n  .room(0.2).gain(0.8)\n  .sometimes(add(note(\"3\"))) // occasional thirds\n  .clip(0.8),\n  \n  // Piano chords underneath\n  note(\"<g2 d3 e3 d3>\")\n  .s(\"gm_piano\")\n  .gain(0.5)\n  .room(0.3),\n  \n  // Basic country rhythm\n  stack(\n    s(\"bd*2, ~ sd\"),\n    s(\"[~ hh]*4\")\n  ).bank(\"RolandTR808\")\n  .gain(0.6)\n).cpm(120)",
  "compileError": null,
  "rawResponse": null,
  "messages": [
    {
      "role": "system",
      "content": "<DOCS>\n# Mini Notation\n\n| Concept | Syntax | Example |\n| --- | --- | --- |\n| Sequence | space | 9<br>1<br>sound(\"bd bd sd hh bd cp sd hh\") |\n| Sample Number | :x | 9<br>1<br>sound(\"hh:0 hh:1 hh:2 hh:3\") |\n| Rests | ~ | 9<br>1<br>sound(\"metal ~ jazz jazz:1\") |\n| Sub-Sequences | \\[\\] | 9<br>1<br>sound(\"bd wind \\[metal jazz\\] hh\") |\n| Sub-Sub-Sequences | \\[\\[\\]\\] | 9<br>1<br>sound(\"bd \\[metal \\[jazz sd\\]\\]\") |\n| Speed up | \\* | 9<br>1<br>sound(\"bd sd\\*2 cp\\*3\") |\n| Parallel | , | 9<br>1<br>sound(\"bd\\*2, hh\\*2 \\[hh oh\\]\") |\n| Slow down | / | 9<br>1<br>note(\"\\[c a f e\\]/2\") |\n| Alternate | <> | 9<br>1<br>note(\"c <e g>\") |\n| Elongate | @ | 9<br>1<br>note(\"c@3 e\") |\n| Replicate | ! | 9<br>1<br>note(\"c!3 e\") |\n\n## Sounds\n\n| Name | Description | Example |\n| --- | --- | --- |\n| sound | plays the sound of the given name | 9<br>1<br>sound(\"bd sd\") |\n| bank | selects the sound bank | 9<br>1<br>sound(\"bd sd\").bank(\"RolandTR909\") |\n| n | select sample number | 9<br>1<br>n(\"0 1 4 2\").sound(\"jazz\") |\n\n## Notes\n\n| Name | Description | Example |\n| --- | --- | --- |\n| note | set pitch as number or letter | 9<br>1<br>note(\"b g e c\").sound(\"piano\") |\n| n + scale | set note in scale | 9<br>1<br>n(\"6 4 2 0\").scale(\"C:minor\").sound(\"piano\") |\n| $: | play patterns in parallel | 9<br>1<br>2<br>$:s(\"bd sd\")<br>$:note(\"c eb g\") |\n\n## Audio Effects\n\n| name | example |\n| --- | --- |\n| lpf | 9<br>1<br>note(\"c2 c3 c2 c3\").s(\"sawtooth\").lpf(\"400 2000\") |\n| vowel | 9<br>1<br>note(\"c3 eb3 g3\").s(\"sawtooth\").vowel(\"<a e i o>\") |\n| gain | 9<br>1<br>s(\"hh\\*16\").gain(\"\\[.25 1\\]\\*4\") |\n| delay | 9<br>1<br>s(\"bd rim bd cp\").delay(.5) |\n| room | 9<br>1<br>s(\"bd rim bd cp\").room(.5) |\n| pan | 9<br>1<br>s(\"bd rim bd cp\").pan(\"0 1\") |\n| speed | 9<br>1<br>s(\"bd rim bd cp\").speed(\"<1 2 -1 -2>\") |\n| range | 9<br>1<br>s(\"hh\\*32\").lpf(saw.range(200,4000)) |\n\n## Pattern Effects\n\n| name | description | example |\n| --- | --- | --- |\n| cpm | sets the tempo in cycles per minute | 9<br>1<br>sound(\"bd sd \\[~ bd\\] sd\").cpm(45) |\n| fast | speed up | 9<br>1<br>sound(\"bd sd \\[~ bd\\] sd\").fast(2) |\n| slow | slow down | 9<br>1<br>sound(\"bd sd \\[~ bd\\] sd\").slow(2) |\n| rev | reverse | 9<br>1<br>n(\"0 2 4 6\").scale(\"C:minor\").rev() |\n| jux | split left/right, modify right | 9<br>1<br>n(\"0 2 4 6\").scale(\"C:minor\").jux(rev) |\n| add | add numbers / notes | 9<br>1<br>n(\"0 2 4 6\".add(\"<0 1 2 1>\")).scale(\"C:minor\") |\n| ply | speed up each event n times | 9<br>1<br>s(\"bd sd\").ply(\"<1 2 3>\") |\n| off | copy, shift time & modify | 9<br>1<br>s(\"bd sd, hh\\*4\").off(1/8,x=>x.speed(2)) |\n\n# First Sounds\n\n## Sounds\n\nPlay a sound with `sound` like this: sound(\"casio\")\n\n`casio` is one of many standard sounds.\n\nTry out a few other sounds:\n```\ninsect wind jazz metal east crow casio space numbers\n```\nYou can select the sample by appending `:` followed by a number to the name: sound(\"casio:1\")\n\n## Drum Sounds\n\nBy default, Strudel comes with a wide selection of drum sounds: sound(\"bd hh sd oh\")\n\nThese letter combinations stand for different parts of a drum set:\n\n- `bd` = **b** ass **d** rum\n- `sd` = **s** nare **d** rum\n- `rim` = **rim** shot\n- `hh` = **h** i **h** at\n- `oh` = **o** pen **h** ihat\n- `lt` = **l** ow tom\n- `mt` = **m** iddle tom\n- `ht` = **h** igh tom\n- `rd` = **r** i **d** e cymbal\n- `cr` = **cr** ash cymbal\n\nTry out different drum sounds!\n\nTo change the sound character of our drums, we can use `bank` to change the drum machine: sound(\"bd hh sd oh\").bank(\"RolandTR909\")\n\nIn this example `RolandTR909` is the name of the drum machine that we’re using. It is a famous drum machine for house and techno beats.\n\nTry changing `RolandTR909` to one of\n\n- `AkaiLinn`\n- `RhythmAce`\n- `RolandTR808`\n- `RolandTR707`\n- `ViscoSpaceDrum`\n\n## Sequences\n\nIn the last example, we already saw that you can play multiple sounds in a sequence by separating them with a space: sound(\"bd hh sd hh\")\n\nNotice how the currently playing sound is highlighted in the code and also visualized below.\nThe longer the sequence, the faster it runs\n\nThe content of a sequence will be squished into what’s called a cycle. A cycle is 2s long by default.\n\n**One per cycle with `< .. >`**\n\nHere is the same sequence, but this time sourrounded with `< .. >` (angle brackets): sound(\"<bd bd hh bd rim bd hh bd>\")\n\nThis will play only one sound per cycle. With these brackets, the tempo doesn’t change when we add or remove elements!\n\nBecause this is now very slow, we can speed it up again like this: sound(\"<bd bd hh bd rim bd hh bd>\\*8\")\nHere, the `*8` means we make the whole thing 8 times faster.\n\nWait a minute, isn’t this the same as without `< ... >*8`? Why do we need it then?\nThat’s true, the special thing about this notation is that the tempo won’t change when you add or remove elements.\n\nchanging the tempo with cpm: sound(\"<bd hh rim hh>\\*8\").cpm(90/4)\ncpm = cycles per minute\nBy default, the tempo is 30 cycles per minute = 120/4 = 1 cycle every 2 seconds\n\nIn western music terms, you could say the above are 8ths notes at 90bpm in 4/4 time.\nBut don’t worry if you don’t know these terms, as they are not required to make music with Strudel.\n\n**Add a rests in a sequence with ’-’ or ’~’** sound(\"bd hh - rim - bd hh rim\")\n\n**Sub-Sequences with \\[brackets\\]**: sound(\"bd \\[hh hh\\] sd \\[hh bd\\] bd - \\[hh sd\\] cp\")\n\n**Multiplication: Speed things up**: sound(\"bd hh\\*2 rim hh\\*3 bd \\[- hh\\*2\\] rim hh\\*2\")\n\n**Multiplication: Speed up subsequences**: sound(\"bd \\[hh rim\\]\\*2 bd \\[hh rim\\]\\*1.5\")\n\n**Multiplication: Speeeeeeeeed things up**: sound(\"bd hh\\*32 rim hh\\*16\")\n\nPitch = really fast rhythm\n\n**Sub-Sub-Sequences with \\[\\[brackets\\]\\]**: sound(\"bd \\[\\[rim rim\\] hh\\] bd cp\")\n\nYou can go as deep as you want!\n\n**Play sequences in parallel with comma**: sound(\"hh hh hh, bd casio\")\n\nYou can use as many commas as you want: sound(\"hh hh hh, bd bd, - casio\")\n\nCommas can also be used inside sub-sequences: sound(\"hh hh hh, bd \\[bd,casio\\]\")\n\nNotice how the 2 above are the same? It is quite common that there are many ways to express the same idea.\n\n**Multiple Lines with backticks** sound(\\`bd\\*2, - cp,\\- \\- \\- oh, hh\\*4,\\[\\- casio\\]\\*2\\`)\n\n**selecting sample numbers separately** Instead of using ”:”, we can also use the `n` function to select sample numbers: n(\"0 1 \\[4 2\\] 3\\*2\").sound(\"jazz\")\n\nThis is shorter and more readable than: sound(\"jazz:0 jazz:1 \\[jazz:4 jazz:2\\] jazz:3\\*2\")\n\n## Recap\n\nNow we’ve learned the basics of the so called Mini-Notation, the rhythm language of Tidal.\nThis is what we’ve learned so far:\n\n| Concept | Syntax | Example |\n| --- | --- | --- |\n| Sequence | space | 9<br>1<br>sound(\"bd bd sd hh\") |\n| Sample Number | :x | 9<br>1<br>sound(\"hh:0 hh:1 hh:2 hh:3\") |\n| Rests | \\- or ~ | 9<br>1<br>sound(\"metal - jazz jazz:1\") |\n| Alternate | <> | 9<br>1<br>sound(\"<bd hh rim oh bd rim>\") |\n| Sub-Sequences | \\[\\] | 9<br>1<br>sound(\"bd wind \\[metal jazz\\] hh\") |\n| Sub-Sub-Sequences | \\[\\[\\]\\] | 9<br>1<br>sound(\"bd \\[metal \\[jazz \\[sd cp\\]\\]\\]\") |\n| Speed up | \\* | 9<br>1<br>sound(\"bd sd\\*2 cp\\*3\") |\n| Parallel | , | 9<br>1<br>sound(\"bd\\*2, hh\\*2 \\[hh oh\\]\") |\n\nThe Mini-Notation is usually used inside some function. These are the functions we’ve seen so far:\n\n| Name | Description | Example |\n| --- | --- | --- |\n| sound | plays the sound of the given name | 9<br>1<br>sound(\"bd sd \\[- bd\\] sd\") |\n| bank | selects the sound bank | 9<br>1<br>sound(\"bd sd \\[- bd\\] sd\").bank(\"RolandTR909\") |\n| cpm | sets the tempo in cycles per minute | 9<br>1<br>sound(\"bd sd \\[- bd\\] sd\").cpm(45) |\n| n | select sample number | 9<br>1<br>n(\"0 1 4 2 0 6 3 2\").sound(\"jazz\") |\n\n## Examples\n\n**Basic rock beat**\nsound(\"\\[bd sd\\]\\*2, hh\\*8\").bank(\"RolandTR505\")\n.cpm(100/4)\n\n**Classic house**\nsound(\"bd\\*4, \\[- cp\\]\\*2, \\[- hh\\]\\*4\").bank(\"RolandTR909\")\n\nNotice that the two patterns are extremely similar.\nCertain drum patterns are reused across genres.\n\nWe Will Rock you\nsound(\"bd\\*2 cp\").bank(\"RolandTR707\").cpm(81/2)\n\n**Yellow Magic Orchestra - Firecracker**\nsound(\"bd sd, - - - hh - hh - -, - perc - perc:1\\*2\")\n\n.bank(\"RolandCompurhythm1000\").cpm(120/2)\n\n**Imitation of a 16 step sequencer**\nsound(\\`\n\n\\[\\- \\- oh - \\] \\[- - - - \\] \\[- - - - \\] \\[- - - - \\],\n\n\\[hh hh - - \\] \\[hh - hh - \\] \\[hh - hh - \\] \\[hh - hh - \\],\n\n\\[\\- \\- \\- \\- \\] \\[cp - - - \\] \\[- - - - \\] \\[cp - - - \\],\n\n\\[bd - - - \\] \\[- - - bd\\] \\[- - bd - \\] \\[- - - bd\\]\n\n\\`).cpm(90/4)\n\n**Another one**\nsound(\\`\n\n\\[\\- \\- \\- \\- \\] \\[\\- \\- \\- \\- \\] \\[\\- \\- \\- \\- \\] \\[\\- \\- oh:1 - \\],\n\n\\[hh hh hh hh\\] \\[hh hh hh hh\\] \\[hh hh hh hh\\] \\[hh hh - - \\],\n\n\\[\\- \\- \\- \\- \\] \\[cp - - - \\] \\[- - - - \\] \\[~ cp - - \\],\n\n\\[bd bd - - \\] \\[- - bd - \\] \\[bd bd - bd \\] \\[- - - - \\]\n\n\\`).bank(\"RolandTR808\").cpm(88/4)\n\n**Not your average drums**\ns(\\`jazz\\*2,\n\ninsect \\[crow metal\\] - -,\n\n\\- space:4 - space:1,\n\n\\- wind\\`)\n\n.cpm(100/2)\n\n# First Notes\n\n| Concept | Syntax | Example |\n| --- | --- | --- |\n| Slow down | / | 9<br>1<br>note(\"\\[c a f e\\]/2\") |\n| Alternate | <> | 9<br>1<br>note(\"c a f <e g>\") |\n| Elongate | @ | 9<br>1<br>note(\"c@3 e\") |\n| Replicate | ! | 9<br>1<br>note(\"c!3 e\") |\n\nNew functions:\n\n| Name | Description | Example |\n| --- | --- | --- |\n| note | set pitch as number or letter | 9<br>1<br>note(\"b g e c\").sound(\"piano\") |\n| scale | interpret `n` as scale degree | 9<br>1<br>n(\"6 4 2 0\").scale(\"C:minor\").sound(\"piano\") |\n| $: | play patterns in parallel | 9<br>1<br>2<br>$:s(\"bd sd\")<br>$:note(\"c eb g\") |\n\n## Examples\n\n**Classy Bassline**\nnote(\"<\\[c2 c3\\]\\*4 \\[bb1 bb2\\]\\*4 \\[f2 f3\\]\\*4 \\[eb2 eb3\\]\\*4>\")\n\n.sound(\"gm\\_synth\\_bass\\_1\")\n\n.lpf(800)// <\\-\\- we'll learn about this soon\n\n**Classy Melody**\n\nn(\\`<\n\n\\[~ 0\\] 2 \\[0 2\\] \\[~ 2\\]\n\n\\[~ 0\\] 1 \\[0 1\\] \\[~ 1\\]\n\n\\[~ 0\\] 3 \\[0 3\\] \\[~ 3\\]\n\n\\[~ 0\\] 2 \\[0 2\\] \\[~ 2\\]\n\n>\\*4\\`).scale(\"C4:minor\")\n\n.sound(\"gm\\_synth\\_strings\\_1\")\n\n**Classy Drums**\n\nsound(\"bd\\*4, \\[~ <sd cp>\\]\\*2, \\[~ hh\\]\\*4\")\n\n.bank(\"RolandTR909\")\n\n**If there just was a way to play all the above at the same time…**\n\nYou can use `$:`\n\n## Playing multiple patterns\n\nIf you want to play multiple patterns at the same time, make sure to write `$:` before each:\n\n$:note(\"<\\[c2 c3\\]\\*4 \\[bb1 bb2\\]\\*4 \\[f2 f3\\]\\*4 \\[eb2 eb3\\]\\*4>\")\n\n.sound(\"gm\\_synth\\_bass\\_1\").lpf(800)\n\n$:n(\\`<\n\n\\[~ 0\\] 2 \\[0 2\\] \\[~ 2\\]\n\n\\[~ 0\\] 1 \\[0 1\\] \\[~ 1\\]\n\n\\[~ 0\\] 3 \\[0 3\\] \\[~ 3\\]\n\n\\[~ 0\\] 2 \\[0 2\\] \\[~ 2\\]\n\n>\\*4\\`).scale(\"C4:minor\")\n\n.sound(\"gm\\_synth\\_strings\\_1\")\n\n$:sound(\"bd\\*4, \\[~ <sd cp>\\]\\*2, \\[~ hh\\]\\*4\")\n\n.bank(\"RolandTR909\")\n\n\nThis is starting to sound like actual music! We have sounds, we have notes, now the last piece of the puzzle is missing: effects\n\n# Pattern Effects\n\nUp until now, most of the functions we’ve seen are what other music programs are typically capable of: sequencing sounds, playing notes, controlling effects.\n\nIn this chapter, we are going to look at functions that are more unique to tidal.\n\n**reverse patterns with rev**\n\nn(\"0 1 \\[4 3\\] 2 0 2 \\[~ 3\\] 4\").sound(\"jazz\").rev()\n\n**play pattern left and modify it right with jux**: n(\"0 1 \\[4 3\\] 2 0 2 \\[~ 3\\] 4\").sound(\"jazz\").jux(rev)\n\nThis is the same as:\n$:n(\"0 1 \\[4 3\\] 2 0 2 \\[~ 3\\] 4\").sound(\"jazz\").pan(0)\n\n$:n(\"0 1 \\[4 3\\] 2 0 2 \\[~ 3\\] 4\").sound(\"jazz\").pan(1).rev()\n\n\n**multiple tempos**\n\nnote(\"c2, eb3 g3 \\[bb3 c4\\]\").sound(\"piano\").slow(\"0.5,1,1.5\")\n\nThis is like doing\n\n$:note(\"c2, eb3 g3 \\[bb3 c4\\]\").s(\"piano\").slow(0.5).color('cyan')\n\n$:note(\"c2, eb3 g3 \\[bb3 c4\\]\").s(\"piano\").slow(1).color('magenta')\n\n$:note(\"c2, eb3 g3 \\[bb3 c4\\]\").s(\"piano\").slow(1.5).color('yellow')\n\n\n**add**\n\nnote(\"c2 \\[eb3,g3\\] \".add(\"<0 <1 -1>>\"))\n\n.color(\"<cyan <magenta yellow>>\").adsr(\"\\[.1 0\\]:.2:\\[1 0\\]\")\n\n.sound(\"gm\\_acoustic\\_bass\").room(.5).cpm(60)\n\nIf you add a number to a note, the note will be treated as if it was a number\n\nWe can add as often as we like:\n\nnote(\"c2 \\[eb3,g3\\]\".add(\"<0 <1 -1>>\").add(\"0,7\"))\n\n.color(\"<cyan <magenta yellow>>\").adsr(\"\\[.1 0\\]:.2:\\[1 0\\]\")\n\n.sound(\"gm\\_acoustic\\_bass\").room(.5).cpm(60)\n\n**add with scale**\n\n\nn(\"0 \\[2 4\\] <3 5> \\[~ <4 1>\\]\".add(\"<0 \\[0,2,4\\]>\"))\n\n.scale(\"C5:minor\").release(.5)\n\n.sound(\"gm\\_xylophone\").room(.5)\n\n**time to stack**\n\n$:n(\"0 \\[2 4\\] <3 5> \\[~ <4 1>\\]\".add(\"<0 \\[0,2,4\\]>\"))\n\n.scale(\"C5:minor\")\n\n.sound(\"gm\\_xylophone\")\n\n.room(.4).delay(.125)\n\n$:note(\"c2 \\[eb3,g3\\]\".add(\"<0 <1 -1>>\"))\n\n.adsr(\"\\[.1 0\\]:.2:\\[1 0\\]\")\n\n.sound(\"gm\\_acoustic\\_bass\")\n\n.room(.5)\n\n$:n(\"0 1 \\[2 3\\] 2\").sound(\"jazz\").jux(rev)\n\n**ply**\n\nsound(\"hh hh, bd rim \\[~ cp\\] rim\").bank(\"RolandTR707\").ply(2)\n\nthis is like writing:\n\nsound(\"hh\\*2 hh\\*2, bd\\*2 rim\\*2 \\[~ cp\\*2\\] rim\\*2\").bank(\"RolandTR707\")\n\nTry patterning the `ply` function, for example using `\"<1 2 1 3>\"`\n\n**off**\n\nn(\"0 \\[4 <3 2>\\] <2 3> \\[~ 1\\]\"\n\n.off(1/16,x=>x.add(4))\n\n//.off(1/8, x=>x.add(7))\n\n).scale(\"<C5:minor Db5:mixolydian>/2\")\n\n.s(\"triangle\").room(.5).dec(.1)\n\nIn the notation `.off(1/16, x=>x.add(4))`, says:\n\n- take the original pattern named as `x`\n- modify `x` with `.add(4)`, and\n- play it offset to the original pattern by `1/16` of a cycle.\n\noff is also useful for modifying other sounds, and can even be nested:\n\ns(\"bd sd \\[rim bd\\] sd,\\[~ hh\\]\\*4\").bank(\"CasioRZ1\")\n\n.off(2/16,x=>x.speed(1.5).gain(.25)\n\n.off(3/16,y=>y.vowel(\"<a e i o>\\*8\")))\n\n| name | description | example |\n| --- | --- | --- |\n| rev | reverse | 9<br>1<br>n(\"0 2 4 6 ~ 7 9 5\").scale(\"C:minor\").rev() |\n| jux | split left/right, modify right | 9<br>1<br>n(\"0 2 4 6 ~ 7 9 5\").scale(\"C:minor\").jux(rev) |\n| add | add numbers / notes | 9<br>1<br>n(\"0 2 4 6 ~ 7 9 5\".add(\"<0 1 2 1>\")).scale(\"C:minor\") |\n| ply | speed up each event n times | 9<br>1<br>s(\"bd sd \\[~ bd\\] sd\").ply(\"<1 2 3>\") |\n| off | copy, shift time & modify | 9<br>1<br>s(\"bd sd \\[~ bd\\] sd, hh\\*8\").off(1/16,x=>x.speed(2)) |\n\n# Samples\n\nSamples are the most common way to make sound with tidal and strudel.\nA sample is a (commonly short) piece of audio that is used as a basis for sound generation, undergoing various transformations.\n\n# Default Samples\n\nBy default, strudel comes with a built-in “sample map”, providing a solid base to play with.\ns(\"bd sd \\[~ bd\\] sd,hh\\*16, misc\")\n\nHere, we are using the `s` function to play back different default samples ( `bd`, `sd`, `hh` and `misc`) to get a drum beat.\n\nFor drum sounds, strudel uses the comprehensive tidal-drum-machines library, with the following naming convention:\n\n| Drum | Abbreviation |\n| --- | --- |\n| Bass drum, Kick drum | bd |\n| Snare drum | sd |\n| Rimshot | rim |\n| Clap | cp |\n| Closed hi-hat | hh |\n| Open hi-hat | oh |\n| Crash | cr |\n| Ride | rd |\n| High tom | ht |\n| Medium tom | mt |\n| Low tom | lt |\n\nMore percussive sounds:\n\n| Source | Abbreviation |\n| --- | --- |\n| Shakers (and maracas, cabasas, etc) | sh |\n| Cowbell | cb |\n| Tambourine | tb |\n| Other percussions | perc |\n| Miscellaneous samples | misc |\n| Effects | fx |\n\n\n# Sound Banks\n\nIf we open the `sounds` tab and then `drum-machines`, we can see that the drum samples are all prefixed with drum machine names: `RolandTR808_bd`, `RolandTR808_sd`, `RolandTR808_hh` etc..\n\nWe _could_ use them like this:\ns(\"RolandTR808\\_bd RolandTR808\\_sd,RolandTR808\\_hh\\*16\")\n\nbut thats obviously a bit much to write. Using the `bank` function, we can shorten this to: s(\"bd sd,hh\\*16\").bank(\"RolandTR808\")\n\nYou could even pattern the bank to switch between different drum machines: s(\"bd sd,hh\\*16\").bank(\"<RolandTR808 RolandTR909>\")\n\nBehind the scenes, `bank` will just prepend the drum machine name to the sample name with `_` to get the full name.\nThis of course only works because the name after `_` ( `bd`, `sd` etc..) is standardized.\nAlso note that some banks won’t have samples for all sounds!\n\n# Selecting Sounds\n\nIf we open the `sounds` tab again, followed by tab `drum machines`, there is also a number behind each name, indicating how many individual samples are available.\nFor example `RolandTR909_hh(4)` means there are 4 samples of a TR909 hihat available.\nBy default, `s` will play the first sample, but we can select the other ones using `n`, starting from 0:\ns(\"hh\\*8\").bank(\"RolandTR909\").n(\"0 1 2 3\")\n\nNumbers that are too high will just wrap around to the beginning\n\ns(\"hh\\*8\").bank(\"RolandTR909\").n(\"0 1 2 3 4 5 6 7\")\n\nHere, 0-3 will play the same sounds as 4-7, because `RolandTR909_hh` only has 4 sounds.\n\nSelecting sounds also works inside the mini notation, using “ `:`” like this: s(\"bd\\*4,hh:0 hh:1 hh:2 hh:3 hh:4 hh:5 hh:6 hh:7\") .bank(\"RolandTR909\")\n\n\n## Specifying Pitch\n\nTo make sure your samples are in tune when playing them with `note`, you can specify a base pitch like this:\n\nsamples({\n\n'gtr':'gtr/0001\\_cleanC.wav',\n\n'moog':{'g3':'moog/005\\_Mighty%20Moog%20G3.wav'},\n\n},'github:tidalcycles/dirt-samples');\n\nnote(\"g3 \\[bb3 c4\\] <g4 f4 eb4 f3>@2\").s(\"gtr,moog\").clip(1)\n\n.gain(.5)\n\nWe can also declare different samples for different regions of the keyboard:\nsamples({\n\n'moog':{\n\n'g2':'moog/004\\_Mighty%20Moog%20G2.wav',\n\n'g3':'moog/005\\_Mighty%20Moog%20G3.wav',\n\n'g4':'moog/006\\_Mighty%20Moog%20G4.wav',\n\n}},'github:tidalcycles/dirt-samples');\n\nnote(\"g2!2 <bb2 c3>!2, <c4@3 \\[<eb4 bb3> g4 f4\\]>\")\n\n.s('moog').clip(1)\n\n.gain(.5).cpm(60)\n\nThe sampler will always pick the closest matching sample for the current note!\n\nNote that this notation for pitched sounds also works inside a `strudel.json` file.\n\n## Shabda\n\nIf you don’t want to select samples by hand, there is also the wonderful tool called [shabda](https://shabda.ndre.gr/).\nWith it, you can enter any sample name(s) to query from [freesound.org](https://freesound.org/). Example:\n\nsamples('shabda:bass:4,hihat:4,rimshot:2')\n\n$:n(\"0 1 2 3 0 1 2 3\").s('bass')\n\n$:n(\"0 1\\*2 2 3\\*2\").s('hihat').clip(1)\n\n$:n(\"~ 0 ~ 1 ~ 0 0 1\").s('rimshot')\n\nYou can also generate artificial voice samples with any text, in multiple languages.\nNote that the language code and the gender parameters are optional and default to `en-GB` and `f`\n\nsamples('shabda/speech:the\\_drum,forever')\n\nsamples('shabda/speech/fr-FR/m:magnifique')\n\n$:s(\"the\\_drum\\*2\").chop(16).speed(rand.range(0.85,1.1))\n\n$:s(\"forever magnifique\").slow(4).late(0.125)\n\n# Sampler Effects\n\nSampler effects are functions that can be used to change the behaviour of sample playback.\n\n### begin\n\na pattern of numbers from 0 to 1. Skips the beginning of each sample, e.g. `0.25` to cut off the first quarter from each sample.\n\n- amount (number\\|Pattern): between 0 and 1, where 1 is the length of the sample\n\nsamples({rave:'rave/AREUREADY.wav'},'github:tidalcycles/dirt-samples')\n\ns(\"rave\").begin(\"<0 .25 .5 .75>\").fast(2)\n\n### end\n\nThe same as .begin, but cuts off the end off each sample.\n\n- length (number\\|Pattern): 1 = whole sample, .5 = half sample, .25 = quarter sample etc..\n\ns(\"bd\\*2,oh\\*4\").end(\"<.1 .2 .5 1>\").fast(2)\n\n### loop\n\nLoops the sample.\nNote that the tempo of the loop is not synced with the cycle tempo.\nTo change the loop region, use loopBegin / loopEnd.\n\n- on (number\\|Pattern): If 1, the sample is looped\n\ns(\"casio\").loop(1)\n\n### loopBegin\n\nSynonyms: `loopb`\n\nBegin to loop at a specific point in the sample (inbetween `begin` and `end`).\nNote that the loop point must be inbetween `begin` and `end`, and before `loopEnd`!\nNote: Samples starting with wt\\_ will automatically loop! (wt = wavetable)\n\n- time (number\\|Pattern): between 0 and 1, where 1 is the length of the sample\n\ns(\"space\").loop(1)\n\n.loopBegin(\"<0 .125 .25>\").\\_scope()\n\n### loopEnd\n\nSynonyms: `loope`\n\nEnd the looping section at a specific point in the sample (inbetween `begin` and `end`).\nNote that the loop point must be inbetween `begin` and `end`, and after `loopBegin`!\n\n- time (number\\|Pattern): between 0 and 1, where 1 is the length of the sample\n\n\ns(\"space\").loop(1)\n\n.loopEnd(\"<1 .75 .5 .25>\").\\_scope()\n\n### cut\n\nIn the style of classic drum-machines, `cut` will stop a playing sample as soon as another samples with in same cutgroup is to be played. An example would be an open hi-hat followed by a closed one, essentially muting the open.\n\n- group (number\\|Pattern): cut group number\n\n\ns(\"\\[oh hh\\]\\*4\").cut(1)\n\n### clip\n\nSynonyms: `legato`\n\nMultiplies the duration with the given number. Also cuts samples off at the end if they exceed the duration.\n\n- factor (number\\|Pattern):\n= 0\n\nnote(\"c a f e\").s(\"piano\").clip(\"<.5 1 2>\")\n\n### loopAt\n\nMakes the sample fit the given number of cycles by changing the speed.\n\nsamples({rhodes:'https://cdn.freesound.org/previews/132/132051\\_316502-lq.mp3'})\n\ns(\"rhodes\").loopAt(2)\n\n### fit\n\nMakes the sample fit its event duration. Good for rhythmical loops like drum breaks.\nSimilar to `loopAt`.\n\nsamples({rhodes:'https://cdn.freesound.org/previews/132/132051\\_316502-lq.mp3'})\n\ns(\"rhodes/2\").fit()\n\n### chop\n\nCuts each sample into the given number of parts, allowing you to explore a technique known as 'granular synthesis'.\nIt turns a pattern of samples into a pattern of parts of samples.\n\nsamples({rhodes:'https://cdn.freesound.org/previews/132/132051\\_316502-lq.mp3'})\n\ns(\"rhodes\")\n\n.chop(4)\n\n.rev()// reverse order of chops\n\n.loopAt(2)// fit sample into 2 cycles\n\n### striate\n\nCuts each sample into the given number of parts, triggering progressive portions of each sample at each loop.\n\ns(\"numbers:0 numbers:1 numbers:2\").striate(6).slow(3)\n\n### slice\n\nChops samples into the given number of slices, triggering those slices with a given pattern of slice numbers.\nInstead of a number, it also accepts a list of numbers from 0 to 1 to slice at specific points.\n\nsamples('github:tidalcycles/dirt-samples')\n\ns(\"breaks165\").slice(8,\"0 1 <2 2\\*2> 3 \\[4 0\\] 5 6 7\".every(3,rev)).slow(0.75)\n\nsamples('github:tidalcycles/dirt-samples')\n\ns(\"breaks125\").fit().slice(\\[0,.25,.5,.75\\],\"0 1 1 <2 3>\")\n\n### splice\n\nWorks the same as slice, but changes the playback speed of each slice to match the duration of its step.\n\nsamples('github:tidalcycles/dirt-samples')\n\ns(\"breaks165\")\n\n.splice(8,\"0 1 \\[2 3 0\\]@2 3 0@2 7\")\n\n### speed\n\nChanges the speed of sample playback, i.e. a cheap way of changing pitch.\n\n- speed (number\\|Pattern): inf to inf, negative numbers play the sample backwards.\n\ns(\"bd\\*6\").speed(\"1 2 4 1 -2 -4\")\n\nspeed(\"1 1.5\\*2 \\[2 1.1\\]\").s(\"piano\").clip(1)\n\nAfter samples, let’s see what [Synths](https://strudel.cc/learn/synths/) afford us.\n\n# Synths\n\nIn addition to the sampling engine, strudel comes with a synthesizer to create sounds on the fly.\n\n## Basic Waveforms\n\nThe basic waveforms are `sine`, `sawtooth`, `square` and `triangle`, which can be selected via `sound` (or `s`):\n\nnote(\"c2 <eb2 <g2 g1>>\".fast(2))\n\n.sound(\"<sawtooth square triangle sine>\")\n\n.\\_scope()\n\nIf you don’t set a `sound` but a `note` the default value for `sound` is `triangle`!\n\n## Noise\n\nYou can also use noise as a source by setting the waveform to: `white`, `pink` or `brown`. These are different\nflavours of noise, here written from hard to soft.\n\nsound(\"<white pink brown>\").\\_scope()\n\nHere’s a more musical example of how to use noise for hihats:\nsound(\"bd\\*2,<white pink brown>\\*8\")\n\n.decay(.04).sustain(0).\\_scope()\n\nSome amount of pink noise can also be added to any oscillator by using the `noise` paremeter:\n\nnote(\"c3\").noise(\"<0.1 0.25 0.5>\").\\_scope()\n\nYou can also use the `crackle` type to play some subtle noise crackles. You can control noise amount by using the `density` parameter:\n\ns(\"crackle\\*4\").density(\"<0.01 0.04 0.2 0.5>\".slow(2)).\\_scope()\n\n### Additive Synthesis\n\nTo tame the harsh sound of the basic waveforms, we can set the `n` control to limit the overtones of the waveform:\n\nnote(\"c2 <eb2 <g2 g1>>\".fast(2))\n\n.sound(\"sawtooth\")\n\n.n(\"<32 16 8 4>\")\n\n.\\_scope()\n\nWhen the `n` control is used on a basic waveform, it defines the number of harmonic partials the sound is getting.\nYou can also set `n` directly in mini notation with `sound`:\n\nnote(\"c2 <eb2 <g2 g1>>\".fast(2))\n\n.sound(\"sawtooth:<32 16 8 4>\")\n\n.\\_scope()\n\nNote for tidal users: `n` in tidal is synonymous to `note` for synths only.\nIn strudel, this is not the case, where `n` will always change timbre, be it though different samples or different waveforms.\n\n## Vibrato\n\n### vib\n\nSynonyms: `vibrato, v`\n\nApplies a vibrato to the frequency of the oscillator.\n\n- frequency (number\\|Pattern): of the vibrato in hertz\n\nnote(\"a e\")\n\n.vib(\"<.5 1 2 4 8 16>\")\n\n.\\_scope()\n\n// change the modulation depth with \":\"\n\nnote(\"a e\")\n\n.vib(\"<.5 1 2 4 8 16>:12\")\n\n.\\_scope()\n\n### vibmod\n\nSynonyms: `vmod`\n\nSets the vibrato depth in semitones. Only has an effect if `vibrato` \\| `vib` \\| `v` is is also set\n\n- depth (number\\|Pattern): of vibrato (in semitones)\n\nnote(\"a e\").vib(4)\n\n.vibmod(\"<.25 .5 1 2 12>\")\n\n.\\_scope()\n\n// change the vibrato frequency with \":\"\n\nnote(\"a e\")\n\n.vibmod(\"<.25 .5 1 2 12>:8\")\n\n.\\_scope()\n\n## FM Synthesis\n\nFM Synthesis is a technique that changes the frequency of a basic waveform rapidly to alter the timbre.\n\nYou can use fm with any of the above waveforms, although the below examples all use the default triangle wave.\n\n### fm\n\nSynonyms: `fmi`\n\nSets the Frequency Modulation of the synth.\nControls the modulation index, which defines the brightness of the sound.\n\n- brightness (number\\|Pattern): modulation index\n\nnote(\"c e g b g e\")\n\n.fm(\"<0 1 2 8 32>\")\n\n.\\_scope()\n\n### fmh\n\nSets the Frequency Modulation Harmonicity Ratio.\nControls the timbre of the sound.\nWhole numbers and simple ratios sound more natural,\nwhile decimal numbers and complex ratios sound metallic.\n\n- harmonicity (number\\|Pattern):\n\nnote(\"c e g b g e\")\n\n.fm(4)\n\n.fmh(\"<1 2 1.5 1.61>\")\n\n.\\_scope()\n\n### fmattack\n\nAttack time for the FM envelope: time it takes to reach maximum modulation\n\n- time (number\\|Pattern): attack time\n\nnote(\"c e g b g e\")\n\n.fm(4)\n\n.fmattack(\"<0 .05 .1 .2>\")\n\n.\\_scope()\n\n### fmdecay\n\nDecay time for the FM envelope: seconds until the sustain level is reached after the attack phase.\n\n- time (number\\|Pattern): decay time\n\nnote(\"c e g b g e\")\n\n.fm(4)\n\n.fmdecay(\"<.01 .05 .1 .2>\")\n\n.fmsustain(.4)\n\n.\\_scope()\n\n### fmsustain\n\nSustain level for the FM envelope: how much modulation is applied after the decay phase\n\n- level (number\\|Pattern): sustain level\n\nnote(\"c e g b g e\")\n\n.fm(4)\n\n.fmdecay(.1)\n\n.fmsustain(\"<1 .75 .5 0>\")\n\n.\\_scope()\n\n### fmenv\n\nRamp type of fm envelope. Exp might be a bit broken..\n\n- type (number\\|Pattern): lin \\| exp\n\nnote(\"c e g b g e\")\n\n.fm(4)\n\n.fmdecay(.2)\n\n.fmsustain(0)\n\n.fmenv(\"<exp lin>\")\n\n.\\_scope()\n\n## Wavetable Synthesis\n\nStrudel can also use the sampler to load custom waveforms as a replacement of the default waveforms used by WebAudio for the base synth. A default set of more than 1000 wavetables is accessible by default (coming from the [AKWF](https://www.adventurekid.se/akrt/waveforms/adventure-kid-waveforms/) set). You can also import/use your own. A wavetable is a one-cycle waveform, which is then repeated to create a sound at the desired frequency. It is a classic but very effective synthesis technique.\n\nAny sample preceded by the `wt_` prefix will be loaded as a wavetable. This means that the `loop` argument will be set to `1` by default. You can scan over the wavetable by using `loopBegin` and `loopEnd` as well.\n\nsamples('bubo:waveforms');\n\nnote(\"<\\[g3,b3,e4\\]!2 \\[a3,c3,e4\\] \\[b3,d3,f#4\\]>\")\n\n.n(\"<1 2 3 4 5 6 7 8 9 10>/2\").room(0.5).size(0.9)\n\n.s('wt\\_flute').velocity(0.25).often(n=>n.ply(2))\n\n.release(0.125).decay(\"<0.1 0.25 0.3 0.4>\").sustain(0)\n\n.cutoff(2000).cutoff(\"<1000 2000 4000>\").fast(4)\n\n.\\_scope()\n\n## ZZFX\n\nThe “Zuper Zmall Zound Zynth” [ZZFX](https://github.com/KilledByAPixel/ZzFX) is also integrated in strudel.\nDeveloped by [Frank Force](https://frankforce.com/), it is a synth and FX engine originally intended to be used for size coding games.\n\nIt has 20 parameters in total, here is a snippet that uses all:\n\nnote(\"c2 eb2 f2 g2\")// also supports freq\n\n.s(\"{z\\_sawtooth z\\_tan z\\_noise z\\_sine z\\_square}%4\")\n\n.zrand(0)// randomization\n\n// zzfx envelope\n\n.attack(0.001)\n\n.decay(0.1)\n\n.sustain(.8)\n\n.release(.1)\n\n// special zzfx params\n\n.curve(1)// waveshape 1-3\n\n.slide(0)// \\+/\\- pitch slide\n\n.deltaSlide(0)// \\+/\\- pitch slide (?)\n\n.noise(0)// make it dirty\n\n.zmod(0)// fm speed\n\n.zcrush(0)// bit crush 0 - 1\n\n.zdelay(0)// simple delay\n\n.pitchJump(0)// \\+/\\- pitch change after pitchJumpTime\n\n.pitchJumpTime(0)// >0 time after pitchJump is applied\n\n.lfo(0)// >0 resets slide + pitchJump + sets tremolo speed\n\n.tremolo(0)// 0-1 lfo volume modulation amount\n\n//.duration(.2) // overwrite strudel event duration\n\n//.gain(1) // change volume\n\n.\\_scope()// vizualise waveform (not zzfx related)\n\n# Audio Effects\n\nWhether you’re using a synth or a sample, you can apply any of the following built-in audio effects.\nAs you might suspect, the effects can be chained together, and they accept a pattern string as their argument.\n\n## Filters\n\nFilters are an essential building block of subtractive synthesis\nStrudel comes with 3 types of filters:\n\n- low-pass filter: low frequencies may _pass_, high frequencies are cut off\n- high-pass filter: high frequencies may _pass_, low frequencies are cut off\n- band-pass filters: only a frequency band may _pass_, low and high frequencies around are cut off\n\nEach filter has 2 parameters:\n\n- cutoff: the frequency at which the filter starts to work. e.g. a low-pass filter with a cutoff of 1000Hz allows frequencies below 1000Hz to pass.\n- q-value: Controls the resonance of the filter. Higher values sound more aggressive. \n\n## lpf\n\nSynonyms: `cutoff, ctf, lp`\n\nApplies the cutoff frequency of the **l** ow- **p** ass **f** ilter.\n\nWhen using mininotation, you can also optionally add the 'lpq' parameter, separated by ':'.\n\n- frequency (number\\|Pattern): audible between 0 and 20000\ns(\"bd sd \\[~ bd\\] sd,hh\\*6\").lpf(\"<4000 2000 1000 500 200 100>\")\ns(\"bd\\*16\").lpf(\"1000:0 1000:10 1000:20 1000:30\")\n\n## lpq\n\nSynonyms: `resonance`\n\nControls the **l** ow- **p** ass **q**-value.\n\n- q (number\\|Pattern): resonance factor between 0 and 50\n\ns(\"bd sd \\[~ bd\\] sd,hh\\*8\").lpf(2000).lpq(\"<0 10 20 30>\")\n\n## hpf\n\nSynonyms: `hp, hcutoff`\n\nApplies the cutoff frequency of the **h** igh- **p** ass **f** ilter.\n\nWhen using mininotation, you can also optionally add the 'hpq' parameter, separated by ':'.\n\n- frequency (number\\|Pattern): audible between 0 and 20000\n\ns(\"bd sd \\[~ bd\\] sd,hh\\*8\").hpf(\"<4000 2000 1000 500 200 100>\")\n\ns(\"bd sd \\[~ bd\\] sd,hh\\*8\").hpf(\"<2000 2000:25>\")\n\n## hpq\n\nSynonyms: `hresonance`\n\nControls the **h** igh- **p** ass **q**-value.\n\n- q (number\\|Pattern): resonance factor between 0 and 50\n\ns(\"bd sd \\[~ bd\\] sd,hh\\*8\").hpf(2000).hpq(\"<0 10 20 30>\")\n\n## bpf\n\nSynonyms: `bandf, bp`\n\nSets the center frequency of the **b** and- **p** ass **f** ilter. When using mininotation, you\ncan also optionally supply the 'bpq' parameter separated by ':'.\n\n- frequency (number\\|Pattern): center frequency\n\ns(\"bd sd \\[~ bd\\] sd,hh\\*6\").bpf(\"<1000 2000 4000 8000>\")\n\n## bpq\n\nSynonyms: `bandq`\n\nSets the **b** and- **p** ass **q**-factor (resonance).\n\n- q (number\\|Pattern): q factor\ns(\"bd sd \\[~ bd\\] sd\").bpf(500).bpq(\"<0 1 2 3>\")\n\n## ftype\n\nSets the filter type. The ladder filter is more aggressive. More types might be added in the future.\n\n- type (number\\|Pattern): 12db (0), ladder (1), or 24db (2)\nnote(\"{f g g c d a a#}%8\").s(\"sawtooth\").lpenv(4).lpf(500).ftype(\"<0 1 2>\").lpq(1)\n\nnote(\"c f g g a c d4\").fast(2)\n\n.sound('sawtooth')\n\n.lpf(200).fanchor(0)\n\n.lpenv(3).lpq(1)\n\n.ftype(\"<ladder 12db 24db>\")\n\n## vowel\n\nFormant filter to make things sound like vowels.\n\n- vowel (string\\|Pattern): You can use a e i o u ae aa oe ue y uh un en an on, corresponding to \\[a\\] \\[e\\] \\[i\\] \\[o\\] \\[u\\] \\[æ\\] \\[ɑ\\] \\[ø\\] \\[y\\] \\[ɯ\\] \\[ʌ\\] \\[œ̃\\] \\[ɛ̃\\] \\[ɑ̃\\] \\[ɔ̃\\]. Aliases: aa = å = ɑ, oe = ø = ö, y = ı, ae = æ.\n\nnote(\"\\[c2 <eb2 <g2 g1>>\\]\\*2\").s('sawtooth')\n\n.vowel(\"<a e i <o u>>\")\n\ns(\"bd sd mt ht bd \\[~ cp\\] ht lt\").vowel(\"\\[a\\|e\\|i\\|o\\|u\\]\")\n\n# Amplitude Envelope\n\nThe amplitude envelope controls the dynamic contour of a sound.\nStrudel uses ADSR envelopes, which are probably the most common way to describe an envelope:\n\n## attack\n\nSynonyms: `att`\n\nAmplitude envelope attack time: Specifies how long it takes for the sound to reach its peak value, relative to the onset.\n\n- attack (number\\|Pattern): time in seconds.\n\nnote(\"c3 e3 f3 g3\").attack(\"<0 .1 .5>\")\n\n## decay\n\nAmplitude envelope decay time: the time it takes after the attack time to reach the sustain level.\nNote that the decay is only audible if the sustain value is lower than 1.\n\n- time (number\\|Pattern): decay time in seconds\nnote(\"c3 e3 f3 g3\").decay(\"<.1 .2 .3 .4>\").sustain(0)\n\n## sustain\n\nSynonyms: `sus`\n\nAmplitude envelope sustain level: The level which is reached after attack / decay, being sustained until the offset.\n\n- gain (number\\|Pattern): sustain level between 0 and 1\n\nnote(\"c3 e3 f3 g3\").decay(.2).sustain(\"<0 .1 .4 .6 1>\")\n\n## release\n\nSynonyms: `rel`\n\nAmplitude envelope release time: The time it takes after the offset to go from sustain level to zero.\n\n- time (number\\|Pattern): release time in seconds\n\nnote(\"c3 e3 g3 c4\").release(\"<0 .1 .4 .6 1>/2\")\n\n## adsr\n\nADSR envelope: Combination of Attack, Decay, Sustain, and Release.\n\n- time (number\\|Pattern): attack time in seconds\n- time (number\\|Pattern): decay time in seconds\n- gain (number\\|Pattern): sustain level (0 to 1)\n- time (number\\|Pattern): release time in seconds\n\nnote(\"\\[c3 bb2 f3 eb3\\]\\*2\").sound(\"sawtooth\").lpf(600).adsr(\".1:.1:.5:.2\")\n\n# Filter Envelope\n\nEach filter can receive an additional filter envelope controlling the cutoff value dynamically. It uses an ADSR envelope similar to the one used for amplitude. There is an additional parameter to control the depth of the filter modulation: `lpenv` \\| `hpenv` \\| `bpenv`. This allows you to play subtle or huge filter modulations just the same by only increasing or decreasing the depth.\n\nnote(\"\\[c eb g <f bb>\\](3,8,<0 1>)\".sub(12))\n\n.s(\"<sawtooth>/64\")\n\n.lpf(sine.range(300,2000).slow(16))\n\n.lpa(0.005)\n\n.lpd(perlin.range(.02,.2))\n\n.lps(perlin.range(0,.5).slow(3))\n\n.lpq(sine.range(2,10).slow(32))\n\n.release(.5)\n\n.lpenv(perlin.range(1,8).slow(2))\n\n.ftype('24db')\n\n.room(1)\n\n.juxBy(.5,rev)\n\n.sometimes(add(note(12)))\n\n.stack(s(\"bd\\*2\").bank('RolandTR909'))\n\n.gain(.5).fast(2)\n\nThere is one filter envelope for each filter type and thus one set of envelope filter parameters preceded either by `lp`, `hp` or `bp`:\n\n- `lpattack`, `lpdecay`, `lpsustain`, `lprelease`, `lpenv`: filter envelope for the lowpass filter.\n\n  - alternatively: `lpa`, `lpd`, `lps`, `lpr` and `lpe`.\n- `hpattack`, `hpdecay`, `hpsustain`, `hprelease`, `hpenv`: filter envelope for the highpass filter.\n\n  - alternatively: `hpa`, `hpd`, `hps`, `hpr` and `hpe`.\n- `bpattack`, `bpdecay`, `bpsustain`, `bprelease`, `bpenv`: filter envelope for the bandpass filter.\n\n  - alternatively: `bpa`, `bpd`, `bps`, `bpr` and `bpe`.\n\n## lpattack\n\nSynonyms: `lpa`\n\nSets the attack duration for the lowpass filter envelope.\n\n- attack (number\\|Pattern): time of the filter envelope\n\nnote(\"c2 e2 f2 g2\")\n\n.sound('sawtooth')\n\n.lpf(300)\n\n.lpa(\"<.5 .25 .1 .01>/4\")\n\n.lpenv(4)\n\n## lpdecay\n\nSynonyms: `lpd`\n\nSets the decay duration for the lowpass filter envelope.\n\n- decay (number\\|Pattern): time of the filter envelope\n\nnote(\"c2 e2 f2 g2\")\n\n.sound('sawtooth')\n\n.lpf(300)\n\n.lpd(\"<.5 .25 .1 0>/4\")\n\n.lpenv(4)\n\n## lpsustain\n\nSynonyms: `lps`\n\nSets the sustain amplitude for the lowpass filter envelope.\n\n- sustain (number\\|Pattern): amplitude of the lowpass filter envelope\n\nnote(\"c2 e2 f2 g2\")\n\n.sound('sawtooth')\n\n.lpf(300)\n\n.lpd(.5)\n\n.lps(\"<0 .25 .5 1>/4\")\n\n.lpenv(4)\n\n## lprelease\n\nSynonyms: `lpr`\n\nSets the release time for the lowpass filter envelope.\n\n- release (number\\|Pattern): time of the filter envelope\n\nnote(\"c2 e2 f2 g2\")\n\n.sound('sawtooth')\n\n.clip(.5)\n\n.lpf(300)\n\n.lpenv(4)\n\n.lpr(\"<.5 .25 .1 0>/4\")\n\n.release(.5)\n\n## lpenv\n\nSynonyms: `lpe`\n\nSets the lowpass filter envelope modulation depth.\n\n- modulation (number\\|Pattern): depth of the lowpass filter envelope between 0 and n\n\nnote(\"c2 e2 f2 g2\")\n\n.sound('sawtooth')\n\n.lpf(300)\n\n.lpa(.5)\n\n.lpenv(\"<4 2 1 0 -1 -2 -4>/4\")\n\n# Pitch Envelope\n\nYou can also control the pitch with envelopes!\nPitch envelopes can breathe life into static sounds:\n\nn(\"<-4,0 5 2 1>\\*<2!3 4>\")\n\n.scale(\"<C F>/8:pentatonic\")\n\n.s(\"gm\\_electric\\_guitar\\_jazz\")\n\n.penv(\"<.5 0 7 -2>\\*2\").vib(\"4:.1\")\n\n.phaser(2).delay(.25).room(.3)\n\n.size(4).fast(1.5)\n\nYou also create some lovely chiptune-style sounds:\n\nn(run(\"<4 8>/16\")).jux(rev)\n\n.chord(\"<C^7 <Db^7 Fm7>>\")\n\n.dict('ireal')\n\n.voicing().add(note(\"<0 1>/8\"))\n\n.dec(.1).room(.2)\n\n.segment(\"<4 \\[2 8\\]>\")\n\n.penv(\"<0 <2 -2>>\").patt(.02).fast(2)\n\nLet’s break down all pitch envelope controls:\n\n## pattack\n\nSynonyms: `patt`\n\nAttack time of pitch envelope.\n\n- time (number\\|Pattern): time in seconds\n\nnote(\"c eb g bb\").pattack(\"0 .1 .25 .5\").slow(2)\n\n## pdecay\n\nSynonyms: `pdec`\n\nDecay time of pitch envelope.\n\n- time (number\\|Pattern): time in seconds\n\nnote(\"<c eb g bb>\").pdecay(\"<0 .1 .25 .5>\")\n\n## prelease\n\nSynonyms: `prel`\n\nRelease time of pitch envelope\n\n- time (number\\|Pattern): time in seconds\n\nnote(\"<c eb g bb> ~\")\n\n.release(.5)// to hear the pitch release\n\n.prelease(\"<0 .1 .25 .5>\")\n\n## penv\n\nAmount of pitch envelope. Negative values will flip the envelope.\nIf you don't set other pitch envelope controls, `pattack:.2` will be the default.\n\n- semitones (number\\|Pattern): change in semitones\n\nnote(\"c\")\n\n.penv(\"<12 7 1 .5 0 -1 -7 -12>\")\n\n## pcurve\n\nCurve of envelope. Defaults to linear. exponential is good for kicks\n\n- type (number\\|Pattern): 0 = linear, 1 = exponential\n\n\nnote(\"g1\\*4\")\n\n.s(\"sine\").pdec(.5)\n\n.penv(32)\n\n.pcurve(\"<0 1>\")\n\n## panchor\n\nSets the range anchor of the envelope:\n\n- anchor 0: range = \\[note, note + penv\\]\n- anchor 1: range = \\[note - penv, note\\]\nIf you don't set an anchor, the value will default to the psustain value.\n\n- anchor (number\\|Pattern): anchor offset\n\nnote(\"c c4\").penv(12).panchor(\"<0 .5 1 .5>\")\n\n# Dynamics\n\n## gain\n\nControls the gain by an exponential amount.\n\n- amount (number\\|Pattern): gain.\n\ns(\"hh\\*8\").gain(\".4!2 1 .4!2 1 .4 1\").fast(2)\n\n## velocity\n\nSets the velocity from 0 to 1. Is multiplied together with gain.\n\ns(\"hh\\*8\")\n\n.gain(\".4!2 1 .4!2 1 .4 1\")\n\n.velocity(\".4 1\")\n\n## compressor\n\nDynamics Compressor. The params are `compressor(\"threshold:ratio:knee:attack:release\")`\ns(\"bd sd \\[~ bd\\] sd,hh\\*8\")\n\n.compressor(\"-20:20:10:.002:.02\")\n\n## postgain\n\nGain applied after all effects have been processed.\n\n\ns(\"bd sd \\[~ bd\\] sd,hh\\*8\")\n\n.compressor(\"-20:20:10:.002:.02\").postgain(1.5)\n\n## xfade\n\nCross-fades between left and right from 0 to 1:\n\n- 0 = (full left, no right)\n- .5 = (both equal)\n- 1 = (no left, full right)\n\nxfade(s(\"bd\\*2\"),\"<0 .25 .5 .75 1>\",s(\"hh\\*8\"))\n\n# Panning\n\n## jux\n\nThe jux function creates strange stereo effects, by applying a function to a pattern, but only in the right-hand channel.\n\ns(\"bd lt \\[~ ht\\] mt cp ~ bd hh\").jux(rev)\n\ns(\"bd lt \\[~ ht\\] mt cp ~ bd hh\").jux(press)\n\n\ns(\"bd lt \\[~ ht\\] mt cp ~ bd hh\").jux(iter(4))\n\n## juxBy\n\nSynonyms: `juxby`\n\nJux with adjustable stereo width. 0 = mono, 1 = full stereo.\n\ns(\"bd lt \\[~ ht\\] mt cp ~ bd hh\").juxBy(\"<0 .5 1>/2\",rev)\n\n## pan\n\nSets position in stereo.\n\n- pan (number\\|Pattern): between 0 and 1, from left to right (assuming stereo), once round a circle (assuming multichannel)\n\ns(\"\\[bd hh\\]\\*2\").pan(\"<.5 1 .5 0>\")\n\ns(\"bd rim sd rim bd ~ cp rim\").pan(sine.slow(2))\n\n# Waveshaping\n\n## coarse\n\nfake-resampling for lowering the sample rate. Caution: This effect seems to only work in chromium based browsers\n\n- factor (number\\|Pattern): 1 for original 2 for half, 3 for a third and so on.\n\ns(\"bd sd \\[~ bd\\] sd,hh\\*8\").coarse(\"<1 4 8 16 32>\")\n\n## crush\n\nbit crusher effect.\n\n- depth (number\\|Pattern): between 1 (for drastic reduction in bit-depth) to 16 (for barely no reduction).\n\ns(\"<bd sd>,hh\\*3\").fast(2).crush(\"<16 8 7 6 5 4 3 2>\")\n\n## distort\n\nSynonyms: `dist`\n\nWave shaping distortion. CAUTION: it can get loud.\nSecond option in optional array syntax (ex: \".9:.5\") applies a postgain to the output.\nMost useful values are usually between 0 and 10 (depending on source gain). If you are feeling adventurous, you can turn it up to 11 and beyond ;)\n\n- distortion (number\\|Pattern):\n\ns(\"bd sd \\[~ bd\\] sd,hh\\*8\").distort(\"<0 2 3 10:.5>\")\nnote(\"d1!8\").s(\"sine\").penv(36).pdecay(.12).decay(.23).distort(\"8:.4\")\n\n# Global Effects\n\n## Local vs Global Effects\n\nWhile the above listed “local” effects will always create a separate effects chain for each event,\nglobal effects use the same chain for all events of the same orbit:\n\n## orbit\n\nAn `orbit` is a global parameter context for patterns. Patterns with the same orbit will share the same global effects.\n\n- number (number\\|Pattern):\nstack(\n\ns(\"hh\\*6\").delay(.5).delaytime(.25).orbit(1),\n\ns(\"~ sd ~ sd\").delay(.5).delaytime(.125).orbit(2)\n\n)\n\n## Delay\n\n### delay\n\nSets the level of the delay signal.\n\nWhen using mininotation, you can also optionally add the 'delaytime' and 'delayfeedback' parameter,\nseparated by ':'.\n\n- level (number\\|Pattern): between 0 and 1\n\ns(\"bd bd\").delay(\"<0 .25 .5 1>\")\n\ns(\"bd bd\").delay(\"0.65:0.25:0.9 0.65:0.125:0.7\")\n\n### delaytime\n\nSynonyms: `delayt, dt`\n\nSets the time of the delay effect.\n\n- seconds (number\\|Pattern): between 0 and Infinity\n\ns(\"bd bd\").delay(.25).delaytime(\"<.125 .25 .5 1>\")\n\n### delayfeedback\n\nSynonyms: `delayfb, dfb`\n\nSets the level of the signal that is fed back into the delay.\nCaution: Values >= 1 will result in a signal that gets louder and louder! Don't do it\n\n- feedback (number\\|Pattern): between 0 and 1\n\ns(\"bd\").delay(.25).delayfeedback(\"<.25 .5 .75 1>\")\n\n## Reverb\n\n### room\n\nSets the level of reverb.\n\nWhen using mininotation, you can also optionally add the 'size' parameter, separated by ':'.\n\n- level (number\\|Pattern): between 0 and 1\n\ns(\"bd sd \\[~ bd\\] sd\").room(\"<0 .2 .4 .6 .8 1>\")\n\ns(\"bd sd \\[~ bd\\] sd\").room(\"<0.9:1 0.9:4>\")\n\n### roomsize\n\nSynonyms: `rsize, sz, size`\n\nSets the room size of the reverb, see `room`.\nWhen this property is changed, the reverb will be recaculated, so only change this sparsely..\n\n- size (number\\|Pattern): between 0 and 10\n\ns(\"bd sd \\[~ bd\\] sd\").room(.8).rsize(1)\n\ns(\"bd sd \\[~ bd\\] sd\").room(.8).rsize(4)\n\n### roomfade\n\nSynonyms: `rfade`\n\nReverb fade time (in seconds).\nWhen this property is changed, the reverb will be recaculated, so only change this sparsely..\n\n- seconds (number): for the reverb to fade\n\ns(\"bd sd \\[~ bd\\] sd\").room(0.5).rlp(10000).rfade(0.5)\n\ns(\"bd sd \\[~ bd\\] sd\").room(0.5).rlp(5000).rfade(4)\n\n### roomlp\n\nSynonyms: `rlp`\n\nReverb lowpass starting frequency (in hertz).\nWhen this property is changed, the reverb will be recaculated, so only change this sparsely..\n\n- frequency (number): between 0 and 20000hz\n\ns(\"bd sd \\[~ bd\\] sd\").room(0.5).rlp(10000)\ns(\"bd sd \\[~ bd\\] sd\").room(0.5).rlp(5000)\n\n### roomdim\n\nSynonyms: `rdim`\n\nReverb lowpass frequency at -60dB (in hertz).\nWhen this property is changed, the reverb will be recaculated, so only change this sparsely..\n\n- frequency (number): between 0 and 20000hz\n\ns(\"bd sd \\[~ bd\\] sd\").room(0.5).rlp(10000).rdim(8000)\n\n\ns(\"bd sd \\[~ bd\\] sd\").room(0.5).rlp(5000).rdim(400)\n\n### iresponse\n\nSynonyms: `ir`\n\nSets the sample to use as an impulse response for the reverb.\n\n- sample (string\\|Pattern): to use as an impulse response\n\n\ns(\"bd sd \\[~ bd\\] sd\").room(.8).ir(\"<shaker\\_large:0 shaker\\_large:2>\")\n\n## Phaser\n\n### phaser\n\nSynonyms: `ph`\n\nPhaser audio effect that approximates popular guitar pedals.\n\n- speed (number\\|Pattern): speed of modulation\nn(run(8)).scale(\"D:pentatonic\").s(\"sawtooth\").release(0.5)\n\n.phaser(\"<1 2 4 8>\")\n\n### phaserdepth\n\nSynonyms: `phd`\n\nThe amount the signal is affected by the phaser effect. Defaults to 0.75\n\n- depth (number\\|Pattern): number between 0 and 1\nn(run(8)).scale(\"D:pentatonic\").s(\"sawtooth\").release(0.5)\n\n.phaser(2).phaserdepth(\"<0 .5 .75 1>\")\n\n### phasercenter\n\nSynonyms: `phc`\n\nThe center frequency of the phaser in HZ. Defaults to 1000\n\n- centerfrequency (number\\|Pattern): in HZ\n\nn(run(8)).scale(\"D:pentatonic\").s(\"sawtooth\").release(0.5)\n\n.phaser(2).phasercenter(\"<800 2000 4000>\")\n\n### phasersweep\n\nSynonyms: `phs`\n\nThe frequency sweep range of the lfo for the phaser effect. Defaults to 2000\n\n- phasersweep (number\\|Pattern): most useful values are between 0 and 4000\n\nn(run(8)).scale(\"D:pentatonic\").s(\"sawtooth\").release(0.5)\n\n.phaser(2).phasersweep(\"<800 2000 4000>\")\n\n# Recipes\n\nThis page shows possible ways to achieve common (or not so common) musical goals.\nThere are often many ways to do a thing and there is no right or wrong.\nThe fun part is that each representation will give you different impulses when improvising.\n\n## Arpeggios\n\nAn arpeggio is when the notes of a chord are played in sequence.\nWe can either write the notes by hand:\n\nnote(\"c eb g c4\")\n\n.clip(2).s(\"gm\\_electric\\_guitar\\_clean\")\n\n…or use scales:\n\nn(\"0 2 4 7\").scale(\"C:minor\")\n\n.clip(2).s(\"gm\\_electric\\_guitar\\_clean\")\n\n…or chord symbols:\n\nn(\"0 1 2 3\").chord(\"Cm\").mode(\"above:c3\").voicing()\n\n.clip(2).s(\"gm\\_electric\\_guitar\\_clean\")\n\n…using off:\n\n\"0\"\n\n.off(1/3,add(2))\n\n.off(1/2,add(4))\n\n.n()\n\n.scale(\"C:minor\")\n\n.s(\"gm\\_electric\\_guitar\\_clean\")\n\n## Chopping Breaks\n\nA sample can be looped and chopped like this:\n\nsamples('github:yaxu/clean-breaks')\n\ns(\"amen/4\").fit().chop(32)\n\nThis fits the break into 8 cycles + chops it in 16 pieces.\nThe chops are not audible yet, because we’re not doing any manipulation.\nLet’s add randmized doubling + reversing:\n\nsamples('github:yaxu/clean-breaks')\n\ns(\"amen/4\").fit().chop(16).cut(1)\n\n.sometimesBy(.5,ply(\"2\"))\n\n.sometimesBy(.25,mul(speed(\"-1\")))\n\nIf we want to specify the order of samples, we can replace `chop` with `slice`:\n\nsamples('github:yaxu/clean-breaks')\n\ns(\"amen/4\").fit()\n\n.slice(8,\"<0 1 2 3 4\\*2 5 6 \\[6 7\\]>\\*2\")\n\n.cut(1).rarely(ply(\"2\"))\n\nIf we use `splice` instead of `slice`, the speed adjusts to the duration of the event:\n\nsamples('github:yaxu/clean-breaks')\n\ns(\"amen\")\n\n.splice(8,\"<0 1 2 3 4\\*2 5 6 \\[6 7\\]>\\*2\")\n\n.cut(1).rarely(ply(\"2\"))\n\nNote that we don’t need `fit`, because `splice` will do that by itself.\n\n## Filter Envelopes\n\nUsing `lpenv`, we can make the filter move:\n\nnote(\"g1 bb1 <c2 eb2> d2\")\n\n.s(\"sawtooth\")\n\n.lpf(400).lpenv(4)\n\n.scope()\n\nThe type of envelope depends on the methods you’re setting. Let’s set `lpa`:\n\nnote(\"g1 bb1 <c2 eb2> d2\")\n\n.s(\"sawtooth\").lpq(8)\n\n.lpf(400).lpa(.2).lpenv(4)\n\n.scope()\n\nNow the filter is attacking, rather than decaying as before (decay is the default). We can also do both\n\nnote(\"g1 bb1 <c2 eb2> d2\")\n\n.s(\"sawtooth\").lpq(8)\n\n.lpf(400).lpa(.1).lpd(.1).lpenv(4)\n\n.scope()\n\nYou can play around with `lpa` \\| `lpd` \\| `lps` \\| `lpd` to see what the filter envelope will do.\n\n## Layering Sounds\n\nWe can layer sounds by separating them with ”,”:\nnote(\"<g1 bb1 d2 f1>\")\n\n.s(\"sawtooth, square\")// <------\n\n.scope()\n\nWe can control the gain of individual sounds like this:\n\nnote(\"<g1 bb1 d2 f1>\")\n\n.s(\"sawtooth, square:0:.5\")// <\\-\\-\\- \"name:number:gain\"\n\n.scope()\n\nFor more control over each voice, we can use `layer`:\n\nnote(\"<g1 bb1 d2 f1>\").layer(\n\nx=>x.s(\"sawtooth\").vib(4),\n\nx=>x.s(\"square\").add(note(12))\n\n).scope()\n\nHere, we give the sawtooth a vibrato and the square is moved an octave up.\nWith `layer`, you can use any pattern method available on each voice, so sky is the limit..\n\n## Oscillator Detune\n\nWe can fatten a sound by adding a detuned version to itself:\n\nnote(\"<g1 bb1 d2 f1>\")\n\n.add(note(\"0,.1\"))// <\\-\\-\\-\\-\\-\\- chorus\n\n.s(\"sawtooth\").scope()\n\nTry out different values, or add another voice!\n\n## Polyrhythms\n\nHere is a simple example of a polyrhythm:\n\n\ns(\"bd\\*2,hh\\*3\")\n\nA polyrhythm is when 2 different tempos happen at the same time.\n\n## Polymeter\n\nThis is a polymeter:\n\ns(\"<bd rim, hh hh oh>\\*4\")\n\nA polymeter is when 2 different bar lengths play at the same tempo.\n\n## Phasing\n\nThis is a phasing:\n\nnote(\"<C D G A Bb D C A G D Bb A>\\*\\[6,6.1\\]\").piano()\n\nPhasing happens when the same sequence plays at slightly different tempos.\n\n## Running through samples\n\nUsing `run` with `n`, we can rush through a sample bank:\n\nsamples('bubo:fox')\n\nn(run(8)).s(\"ftabla\")\n\nThis works great with sample banks that contain similar sounds, like in this case different recordings of a tabla.\nOften times, you’ll hear the beginning of the phrase not where the pattern begins.\nIn this case, I hear the beginning at the third sample, which can be accounted for with `early`.\n\n\nsamples('bubo:fox')\n\nn(run(8)).s(\"ftabla\").early(2/8)\n\nLet’s add some randomness:\n\n\nsamples('bubo:fox')\n\nn(run(8)).s(\"ftabla\").early(2/8)\n\n.sometimes(mul(speed(\"1.5\")))\n\n## Tape Warble\n\nWe can emulate a pitch warbling effect like this:\n\n\nnote(\"<c4 bb f eb>\\*8\")\n\n.add(note(perlin.range(0,.5)))// <\\-\\-\\-\\-\\-\\- warble\n\n.clip(2).s(\"gm\\_electric\\_guitar\\_clean\")\n\n## Sound Duration\n\nThere are a number of ways to change the sound duration. Using clip:\n\nnote(\"f ab bb c\")\n\n.clip(\"<2 1 .5 .25>\")\n\nThe value of clip is relative to the duration of each event.\nWe can also create overlaps using release:\n\nnote(\"f ab bb c\")\n\n.release(\"<2 1 .5 .25>\")\n\nThis will smoothly fade out each sound for the given number of seconds.\nWe could also make the notes shorter by using a decay envelope:\n\nnote(\"f ab bb c\")\n\n.decay(\"<2 1 .5 .25>\")\n\nWhen using samples, we also have `.end` to cut relative to the sample length:\n\n\ns(\"oh\\*4\").end(\"<1 .5 .25 .1>\")\n\nCompare that to clip:\n\ns(\"oh\\*4\").clip(\"<1 .5 .25 .1>\")\n\nor decay:\n\ns(\"oh\\*4\").decay(\"<1 .5 .25 .1>\")\n\n## Wavetable Synthesis\n\nYou can loop a sample with `loop` / `loopEnd`:\nnote(\"<c eb g f>\").s(\"bd\").loop(1).loopEnd(.05).gain(.2)\n\nThis allows us to play the first 5% of the bass drum as a synth!\nTo simplify loading wavetables, any sample that starts with `wt_` will be looped automatically:\n\nsamples('github:bubobubobubobubo/dough-waveforms')\n\nnote(\"c eb g bb\").s(\"wt\\_dbass\").clip(2)\n\nRunning through different wavetables can also give interesting variations:\n\nsamples('github:bubobubobubobubo/dough-waveforms')\n\nnote(\"c2\\*8\").s(\"wt\\_dbass\").n(run(8)).fast(2)\n\n…adding a filter envelope + reverb:\n\nsamples('github:bubobubobubobubo/dough-waveforms')\n\nnote(\"c2\\*8\").s(\"wt\\_dbass\").n(run(8))\n\n.lpf(perlin.range(100,1000).slow(8))\n\n.lpenv(-3).lpa(.1).room(.5).fast(2)\n\n\n# Metadata\nYou can optionally add some music metadata in your Strudel code, by using tags in code comments:\n\n// @title Hey Hoo\n// @by Sam Tagada\n// @license CC BY-NC-SA\nLike other comments, those are ignored by Strudel, but it can be used by other tools to retrieve some information about the music.\nAvailable tags are:\n@title: music title\n@by: music author(s)\n@details: some additional information about the music\n@genre: music genre(s) (pop, jazz, etc)\n\n**Strudel Visual Feedback Cheatsheet**\n*(inline = `_function()`, background = `function()`)*\n\n---\n\n# Mini-notation Highlighting\n\n```js\nn(\"<0 2 1 3 2>*8\").scale(\"<A1 D2>/4:minor:pentatonic\")\n.s(\"supersaw\").lpf(300).lpenv(\"<4 3 2>*4\").color(\"cyan magenta\")\n```\n\n* Wrap mini-notation in `\" \"` or \\` \\` to auto-highlight.\n* `.color(\"…\")` (space-separated list → patterned colors).\n\n---\n\n### Punchcard / Pianoroll\n\n```js\nnote(\"c a f e\").color(\"white\")._punchcard({cycles:4, labels:1})\n```\n\n* **Punchcard** shows *post-transform* pattern (lightweight).\n* **Pianoroll** shows raw notes.\n* Key opts: `cycles`, `playhead`, `labels`, `flipTime`, `flipValues`,\n  `active`, `inactive`, `smear`, `hideInactive`.\n\n---\n\n### Spiral\n\n```js\nnote(\"c2 a2 eb2\").euclid(5,8)._spiral({steady:.96, stretch:1})\n```\n\n* Visual spiral of timeline.\n* Useful opts: `stretch`, `size`, `thickness`, `steady`, `logSpiral`, `fade`.\n\n---\n\n### Scope (oscilloscope)\n\n```js\ns(\"sawtooth\")._scope({align:1, thickness:3, scale:0.25})\n```\n\n* Time-domain view.\n* Main opts: `align`, `color`, `thickness`, `scale`, `trigger`.\n\n---\n\n### Pitchwheel\n\n```js\nn(\"0 .. 12\").scale(\"C:chromatic\").s(\"saw\")._pitchwheel({edo:12, root:\"C\"})\n```\n\n* One-octave pitch circle.\n* Core opts: `edo`, `root`, `thickness`, `mode`.\n\n---\n\n### Spectrum\n\n```js\ns(\"sine\").dec(.3).room(.5)._spectrum({min:-80, max:0, speed:1})\n```\n\n* Frequency analyzer.\n* Opts: `min`, `max`, `speed`, `thickness`.\n\n---\n\n### markcss\n\n```js\nnote(\"c a f e\").markcss('text-decoration:underline')\n```\n\n* Override CSS of highlighted events (single quotes).\n\n---\n\n#### Global vs. Inline\n\n| Visual call            | Where it appears                     |\n| ---------------------- | ------------------------------------ |\n| `pattern.punchcard()`  | full-page background                 |\n| `pattern._punchcard()` | inside code block (multiple allowed) |\n\nUse this sheet to pick a visual, add `_` for inline, and tweak the handful of options you actually need.\n\n# Drum machines\nakaimpc60_bd(2) akaimpc60_sd(3)\nalesissr16_bd(13) alesissr16_sd(12)\nbossdr110_bd(1) bossdr110_sd(1)\ndrumulator_bd(1) drumulator_sd(1)\nemusp12_bd(14) emusp12_sd(21)\nlinndrum_bd(1) linndrum_sd(3)\nlinnlm1_bd(4) linnlm1_sd(1)\nlinnlm2_bd(4) linnlm2_sd(4)\noberheimdmx_bd(3) oberheimdmx_sd(3)\nrolandtr505_bd(1) rolandtr505_sd(1)\nrolandtr606_bd(1) rolandtr606_sd(1)\nrolandtr707_bd(2) rolandtr707_sd(2)\nrolandtr727_perc(10)\nrolandtr808_bd(25) rolandtr808_sd(25)\nrolandtr909_bd(4) rolandtr909_sd(16)\nyamaharx5_bd(2) yamaharx5_sd(3)\nyamahary30_bd(13) yamahary30_sd(21)\nmpc1000_bd(5) mpc1000_sd(4)\nsr16_bd(13) sr16_sd(12)\nddr30_bd(8) ddr30_sd(8)\nsp12_bd(14) sp12_sd(21)\ndr550_bd(5) dr550_sd(6)\nmc303_bd(16) mc303_sd(26)\n\n# synths\nsine square sawtooth triangle supersaw pulse white pink\ngm_lead_1_square(3) gm_lead_2_sawtooth(7) gm_lead_5_charang(10)\ngm_synth_bass_1(10) gm_synth_bass_2(7)\ngm_pad_new_age(12) gm_pad_warm(7) gm_pad_sweep(7)\ngm_string_ensemble_1(11) gm_voice_oohs(6)\ngm_piano(32)\ngm_epiano1(11) gm_epiano2(9)\ngm_choir_aahs(9)\ngm_violin(9) gm_cello(6)\ngm_flute(5) gm_clarinet(6) gm_oboe(5)\ngm_acoustic_guitar_steel(10) gm_distortion_guitar(7)\ngm_overdriven_guitar(10)\n\n# samples\nagogo(5) anvil(9) balafon(6) balafon_hard(6) balafon_soft(6) ballwhistle(2) bassdrum1(8) bassdrum2(30) belltree(6) bongo(28) brakedrum(17) cabasa(6) cajon(18) casio(3) clap(10) clash(10) clash2(5) clave(6) clavisynth(19) conga(34) cowbell(13) crow(4) dantranh(17) dantranh_tremolo(16) dantranh_vibrato(16) darbuka(20) didgeridoo(12) east(9) fingercymbal(1) flexatone(8) fmpiano(22) folkharp(29) framedrum(18) glockenspiel(7) gong(7) gong2(6) guiro(5) handbells(3) handchimes(19) harmonica(9) harmonica_soft(10) harmonica_vib(10) harp(23) hihat(15) insect(3) jazz(8) kalimba(11) kalimba2(25) kalimba3(22) kalimba4(22) kalimba5(14) kawai(37) marimba(10) marktrees(6) metal(10) num(21) numbers(9) ocarina(11) ocarina_small(10) ocarina_small_stacc(13) ocarina_vib(10) oceandrum(3) organ_4inch(27) organ_8inch(27) organ_full(27) piano(29) piano1(22) pipeorgan_loud(21) pipeorgan_loud_pedal(11) pipeorgan_quiet(21) pipeorgan_quiet_pedal(11) psaltery_bow(11) psaltery_pluck(11) psaltery_spiccato(11) ratchet(8) recorder_alto_stacc(12) recorder_alto_sus(12) recorder_alto_vib(12) recorder_bass_stacc(15) recorder_bass_sus(12) recorder_bass_vib(14) recorder_soprano_stacc(12) recorder_soprano_sus(13) recorder_tenor_stacc(12) recorder_tenor_sus(13) recorder_tenor_vib(14) sax(23) sax_stacc(23) sax_vib(19) saxello(8) saxello_stacc(8) saxello_vib(8) shaker_large(6) shaker_small(16) siren(5) slapstick(5) sleighbells(6) slitdrum(6) snare_hi(8) snare_low(20) snare_modern(72) snare_rim(4) space(18) steinway(42) strumstick(19) super64(13) super64_acc(13) super64_vib(13) sus_cymbal(25) sus_cymbal2(23) tambourine(7) tambourine2(7) timpani(30) timpani_roll(10) timpani2(204) tom_mallet(8) tom_rim(6) tom_stick(8) tom2_mallet(8) tom2_rim(6) tom2_stick(8) trainwhistle(6) triangles(37) tubularbells(9) tubularbells2(11) vibraphone(11) vibraphone_bowed(6) vibraphone_soft(11) vibraslap(4) wind(10) wineglass(4) wineglass_slow(4) woodblock(10) xylophone_hard_ff(8) xylophone_hard_pp(8) xylophone_medium_ff(8) xylophone_medium_pp(8) xylophone_soft_ff(8) xylophone_soft_pp(8)\n\n# Examples\n```\n// \"acidic tooth\" @by eddyflux\n// @version 1.0\n  setcps(1)\n  stack(\n    note(\"[<g1 f1>/8](<3 5>,8)\")\n    .clip(perlin.range(.15,1.5))\n    .release(.1)\n    .s(\"sawtooth\")\n    .lpf(sine.range(400,800).slow(16))\n    .lpq(cosine.range(6,14).slow(3))\n    .lpenv(sine.mul(4).slow(4))\n    .lpd(.2).lpa(.02)\n    .ftype('24db')\n    .rarely(add(note(12)))\n    .room(.2).shape(.3).postgain(.5)\n    .superimpose(x=>x.add(note(12)).delay(.5).bpf(1000))\n    .gain(\"[.2 1@3]*2\") // fake sidechain\n    ,\n    stack(\n      s(\"bd*2\").mask(\"<0@4 1@16>\"),\n      s(\"hh*8\").gain(saw.mul(saw.fast(2))).clip(sine)\n      .mask(\"<0@8 1@16>\")\n    ).bank('RolandTR909')\n```\n```\n// \"coastline\" @by eddyflux\n// @version 1.0\nsamples('github:eddyflux/crate')\nsetcps(.75)\nlet chords = chord(\"<Bbm9 Fm9>/4\").dict('ireal')\nstack(\n  stack( // DRUMS\n    s(\"bd\").struct(\"<[x*<1 2> [~@3 x]] x>\"),\n    s(\"~ [rim, sd:<2 3>]\").room(\"<0 .2>\"),\n    n(\"[0 <1 3>]*<2!3 4>\").s(\"hh\"),\n    s(\"rd:<1!3 2>*2\").mask(\"<0 0 1 1>/16\").gain(.5)\n  ).bank('crate')\n  .mask(\"<[0 1] 1 1 1>/16\".early(.5))\n  , // CHORDS\n  chords.offset(-1).voicing().s(\"gm_epiano1:1\")\n  .phaser(4).room(.5)\n  , // MELODY\n  n(\"<0!3 1*2>\").set(chords).mode(\"root:g2\")\n  .voicing().s(\"gm_acoustic_bass\"),\n  chords.n(\"[0 <4 3 <2 5>>*2](<3 5>,8)\")\n  .anchor(\"D5\").voicing()\n  .segment(4).clip(rand.range(.4,.8))\n  .room(.75).shape(.3).delay(.25)\n  .fm(sine.range(3,8).slow(8))\n  .lpf(sine.range(500,1000).slow(8)).lpq(5)\n  .rarely(ply(\"2\")).chunk(4, fast(2))\n  .gain(perlin.range(.6, .9))\n  .mask(\"<0 1 1 0>/16\")\n)\n.late(\"[0 .01]*4\").late(\"[0 .01]*2\").size(4)\n```\n</DOCS>\n\n<RESPONSE_INSTRUCTIONS>\nGenerate valid Strudel pattern code using the Strudel.cc API.\n\nOutput format:\n<CODE>\n[your strudel pattern code here]\n</CODE>\n\nRequirements:\n- Use ONLY valid Strudel functions.\n- Put the code inside <CODE> tags\n- You can pre-face with your creative freedom.\n- The code must be executable in Strudel\n\nExample outputs:\n<CODE>\nn(\"<0 2 1 3 2>*8\")\n.scale(\"<A1 D2>/4:minor:pentatonic\")\n.s(\"supersaw\").lpf(300).lpenv(\"<4 3 2>*4\")\n</CODE>\n\nThe user will provide a music description. Respond with the Strudel code in <CODE> tags. \n</RESPONSE_INSTRUCTIONS>"
    },
    {
      "role": "user",
      "content": "A country music melody"
    },
    {
      "role": "assistant",
      "content": "I'll create a country-style melody using guitar and piano sounds with a typical country rhythm pattern.\n\n<CODE>\nstack(\n  // Main guitar melody with country twang\n  note(\"g3 a3 [b3 a3] g3, [~ e4] [d4 b3] a3 g3\")\n  .s(\"gm_acoustic_guitar_steel\")\n  .room(0.2).gain(0.8)\n  .sometimes(add(note(\"3\"))) // occasional thirds\n  .clip(0.8),\n  \n  // Piano chords underneath\n  note(\"<g2 d3 e3 d3>\")\n  .s(\"gm_piano\")\n  .gain(0.5)\n  .room(0.3),\n  \n  // Basic country rhythm\n  stack(\n    s(\"bd*2, ~ sd\"),\n    s(\"[~ hh]*4\")\n  ).bank(\"RolandTR808\")\n  .gain(0.6)\n).cpm(120)\n</CODE>"
    }
  ]
}