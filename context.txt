<DOCS>
# Mini Notation

| Concept | Syntax | Example |
| --- | --- | --- |
| Sequence | space | 9<br>1<br>sound("bd bd sd hh bd cp sd hh") |
| Sample Number | :x | 9<br>1<br>sound("hh:0 hh:1 hh:2 hh:3") |
| Rests | ~ | 9<br>1<br>sound("metal ~ jazz jazz:1") |
| Sub-Sequences | \[\] | 9<br>1<br>sound("bd wind \[metal jazz\] hh") |
| Sub-Sub-Sequences | \[\[\]\] | 9<br>1<br>sound("bd \[metal \[jazz sd\]\]") |
| Speed up | \* | 9<br>1<br>sound("bd sd\*2 cp\*3") |
| Parallel | , | 9<br>1<br>sound("bd\*2, hh\*2 \[hh oh\]") |
| Slow down | / | 9<br>1<br>note("\[c a f e\]/2") |
| Alternate | <> | 9<br>1<br>note("c <e g>") |
| Elongate | @ | 9<br>1<br>note("c@3 e") |
| Replicate | ! | 9<br>1<br>note("c!3 e") |

## Sounds

| Name | Description | Example |
| --- | --- | --- |
| sound | plays the sound of the given name | 9<br>1<br>sound("bd sd") |
| bank | selects the sound bank | 9<br>1<br>sound("bd sd").bank("RolandTR909") |
| n | select sample number | 9<br>1<br>n("0 1 4 2").sound("jazz") |

## Notes

| Name | Description | Example |
| --- | --- | --- |
| note | set pitch as number or letter | 9<br>1<br>note("b g e c").sound("piano") |
| n + scale | set note in scale | 9<br>1<br>n("6 4 2 0").scale("C:minor").sound("piano") |
| $: | play patterns in parallel | 9<br>1<br>2<br>$:s("bd sd")<br>$:note("c eb g") |

## Audio Effects

| name | example |
| --- | --- |
| lpf | 9<br>1<br>note("c2 c3 c2 c3").s("sawtooth").lpf("400 2000") |
| vowel | 9<br>1<br>note("c3 eb3 g3").s("sawtooth").vowel("<a e i o>") |
| gain | 9<br>1<br>s("hh\*16").gain("\[.25 1\]\*4") |
| delay | 9<br>1<br>s("bd rim bd cp").delay(.5) |
| room | 9<br>1<br>s("bd rim bd cp").room(.5) |
| pan | 9<br>1<br>s("bd rim bd cp").pan("0 1") |
| speed | 9<br>1<br>s("bd rim bd cp").speed("<1 2 -1 -2>") |
| range | 9<br>1<br>s("hh\*32").lpf(saw.range(200,4000)) |

## Pattern Effects

| name | description | example |
| --- | --- | --- |
| cpm | sets the tempo in cycles per minute | 9<br>1<br>sound("bd sd \[~ bd\] sd").cpm(45) |
| fast | speed up | 9<br>1<br>sound("bd sd \[~ bd\] sd").fast(2) |
| slow | slow down | 9<br>1<br>sound("bd sd \[~ bd\] sd").slow(2) |
| rev | reverse | 9<br>1<br>n("0 2 4 6").scale("C:minor").rev() |
| jux | split left/right, modify right | 9<br>1<br>n("0 2 4 6").scale("C:minor").jux(rev) |
| add | add numbers / notes | 9<br>1<br>n("0 2 4 6".add("<0 1 2 1>")).scale("C:minor") |
| ply | speed up each event n times | 9<br>1<br>s("bd sd").ply("<1 2 3>") |
| off | copy, shift time & modify | 9<br>1<br>s("bd sd, hh\*4").off(1/8,x=>x.speed(2)) |

# First Sounds

## Sounds

Play a sound with `sound` like this: sound("casio")

`casio` is one of many standard sounds.

Try out a few other sounds:
```
insect wind jazz metal east crow casio space numbers
```
You can select the sample by appending `:` followed by a number to the name: sound("casio:1")

## Drum Sounds

By default, Strudel comes with a wide selection of drum sounds: sound("bd hh sd oh")

These letter combinations stand for different parts of a drum set:

- `bd` = **b** ass **d** rum
- `sd` = **s** nare **d** rum
- `rim` = **rim** shot
- `hh` = **h** i **h** at
- `oh` = **o** pen **h** ihat
- `lt` = **l** ow tom
- `mt` = **m** iddle tom
- `ht` = **h** igh tom
- `rd` = **r** i **d** e cymbal
- `cr` = **cr** ash cymbal

Try out different drum sounds!

To change the sound character of our drums, we can use `bank` to change the drum machine: sound("bd hh sd oh").bank("RolandTR909")

In this example `RolandTR909` is the name of the drum machine that we’re using. It is a famous drum machine for house and techno beats.

Try changing `RolandTR909` to one of

- `AkaiLinn`
- `RhythmAce`
- `RolandTR808`
- `RolandTR707`
- `ViscoSpaceDrum`

## Sequences

In the last example, we already saw that you can play multiple sounds in a sequence by separating them with a space: sound("bd hh sd hh")

Notice how the currently playing sound is highlighted in the code and also visualized below.
The longer the sequence, the faster it runs

The content of a sequence will be squished into what’s called a cycle. A cycle is 2s long by default.

**One per cycle with `< .. >`**

Here is the same sequence, but this time sourrounded with `< .. >` (angle brackets): sound("<bd bd hh bd rim bd hh bd>")

This will play only one sound per cycle. With these brackets, the tempo doesn’t change when we add or remove elements!

Because this is now very slow, we can speed it up again like this: sound("<bd bd hh bd rim bd hh bd>\*8")
Here, the `*8` means we make the whole thing 8 times faster.

Wait a minute, isn’t this the same as without `< ... >*8`? Why do we need it then?
That’s true, the special thing about this notation is that the tempo won’t change when you add or remove elements.

changing the tempo with cpm: sound("<bd hh rim hh>\*8").cpm(90/4)
cpm = cycles per minute
By default, the tempo is 30 cycles per minute = 120/4 = 1 cycle every 2 seconds

In western music terms, you could say the above are 8ths notes at 90bpm in 4/4 time.
But don’t worry if you don’t know these terms, as they are not required to make music with Strudel.

**Add a rests in a sequence with ’-’ or ’~’** sound("bd hh - rim - bd hh rim")

**Sub-Sequences with \[brackets\]**: sound("bd \[hh hh\] sd \[hh bd\] bd - \[hh sd\] cp")

**Multiplication: Speed things up**: sound("bd hh\*2 rim hh\*3 bd \[- hh\*2\] rim hh\*2")

**Multiplication: Speed up subsequences**: sound("bd \[hh rim\]\*2 bd \[hh rim\]\*1.5")

**Multiplication: Speeeeeeeeed things up**: sound("bd hh\*32 rim hh\*16")

Pitch = really fast rhythm

**Sub-Sub-Sequences with \[\[brackets\]\]**: sound("bd \[\[rim rim\] hh\] bd cp")

You can go as deep as you want!

**Play sequences in parallel with comma**: sound("hh hh hh, bd casio")

You can use as many commas as you want: sound("hh hh hh, bd bd, - casio")

Commas can also be used inside sub-sequences: sound("hh hh hh, bd \[bd,casio\]")

Notice how the 2 above are the same? It is quite common that there are many ways to express the same idea.

**Multiple Lines with backticks** sound(\`bd\*2, - cp,\- \- \- oh, hh\*4,\[\- casio\]\*2\`)

**selecting sample numbers separately** Instead of using ”:”, we can also use the `n` function to select sample numbers: n("0 1 \[4 2\] 3\*2").sound("jazz")

This is shorter and more readable than: sound("jazz:0 jazz:1 \[jazz:4 jazz:2\] jazz:3\*2")

## Recap

Now we’ve learned the basics of the so called Mini-Notation, the rhythm language of Tidal.
This is what we’ve learned so far:

| Concept | Syntax | Example |
| --- | --- | --- |
| Sequence | space | 9<br>1<br>sound("bd bd sd hh") |
| Sample Number | :x | 9<br>1<br>sound("hh:0 hh:1 hh:2 hh:3") |
| Rests | \- or ~ | 9<br>1<br>sound("metal - jazz jazz:1") |
| Alternate | <> | 9<br>1<br>sound("<bd hh rim oh bd rim>") |
| Sub-Sequences | \[\] | 9<br>1<br>sound("bd wind \[metal jazz\] hh") |
| Sub-Sub-Sequences | \[\[\]\] | 9<br>1<br>sound("bd \[metal \[jazz \[sd cp\]\]\]") |
| Speed up | \* | 9<br>1<br>sound("bd sd\*2 cp\*3") |
| Parallel | , | 9<br>1<br>sound("bd\*2, hh\*2 \[hh oh\]") |

The Mini-Notation is usually used inside some function. These are the functions we’ve seen so far:

| Name | Description | Example |
| --- | --- | --- |
| sound | plays the sound of the given name | 9<br>1<br>sound("bd sd \[- bd\] sd") |
| bank | selects the sound bank | 9<br>1<br>sound("bd sd \[- bd\] sd").bank("RolandTR909") |
| cpm | sets the tempo in cycles per minute | 9<br>1<br>sound("bd sd \[- bd\] sd").cpm(45) |
| n | select sample number | 9<br>1<br>n("0 1 4 2 0 6 3 2").sound("jazz") |

## Examples

**Basic rock beat**
sound("\[bd sd\]\*2, hh\*8").bank("RolandTR505")
.cpm(100/4)

**Classic house**
sound("bd\*4, \[- cp\]\*2, \[- hh\]\*4").bank("RolandTR909")

Notice that the two patterns are extremely similar.
Certain drum patterns are reused across genres.

We Will Rock you
sound("bd\*2 cp").bank("RolandTR707").cpm(81/2)

**Yellow Magic Orchestra - Firecracker**
sound("bd sd, - - - hh - hh - -, - perc - perc:1\*2")

.bank("RolandCompurhythm1000").cpm(120/2)

**Imitation of a 16 step sequencer**
sound(\`

\[\- \- oh - \] \[- - - - \] \[- - - - \] \[- - - - \],

\[hh hh - - \] \[hh - hh - \] \[hh - hh - \] \[hh - hh - \],

\[\- \- \- \- \] \[cp - - - \] \[- - - - \] \[cp - - - \],

\[bd - - - \] \[- - - bd\] \[- - bd - \] \[- - - bd\]

\`).cpm(90/4)

**Another one**
sound(\`

\[\- \- \- \- \] \[\- \- \- \- \] \[\- \- \- \- \] \[\- \- oh:1 - \],

\[hh hh hh hh\] \[hh hh hh hh\] \[hh hh hh hh\] \[hh hh - - \],

\[\- \- \- \- \] \[cp - - - \] \[- - - - \] \[~ cp - - \],

\[bd bd - - \] \[- - bd - \] \[bd bd - bd \] \[- - - - \]

\`).bank("RolandTR808").cpm(88/4)

**Not your average drums**
s(\`jazz\*2,

insect \[crow metal\] - -,

\- space:4 - space:1,

\- wind\`)

.cpm(100/2)

# First Notes

| Concept | Syntax | Example |
| --- | --- | --- |
| Slow down | / | 9<br>1<br>note("\[c a f e\]/2") |
| Alternate | <> | 9<br>1<br>note("c a f <e g>") |
| Elongate | @ | 9<br>1<br>note("c@3 e") |
| Replicate | ! | 9<br>1<br>note("c!3 e") |

New functions:

| Name | Description | Example |
| --- | --- | --- |
| note | set pitch as number or letter | 9<br>1<br>note("b g e c").sound("piano") |
| scale | interpret `n` as scale degree | 9<br>1<br>n("6 4 2 0").scale("C:minor").sound("piano") |
| $: | play patterns in parallel | 9<br>1<br>2<br>$:s("bd sd")<br>$:note("c eb g") |

## Examples

**Classy Bassline**
note("<\[c2 c3\]\*4 \[bb1 bb2\]\*4 \[f2 f3\]\*4 \[eb2 eb3\]\*4>")

.sound("gm\_synth\_bass\_1")

.lpf(800)// <\-\- we'll learn about this soon

**Classy Melody**

n(\`<

\[~ 0\] 2 \[0 2\] \[~ 2\]

\[~ 0\] 1 \[0 1\] \[~ 1\]

\[~ 0\] 3 \[0 3\] \[~ 3\]

\[~ 0\] 2 \[0 2\] \[~ 2\]

>\*4\`).scale("C4:minor")

.sound("gm\_synth\_strings\_1")

**Classy Drums**

sound("bd\*4, \[~ <sd cp>\]\*2, \[~ hh\]\*4")

.bank("RolandTR909")

**If there just was a way to play all the above at the same time…**

You can use `$:`

## Playing multiple patterns

If you want to play multiple patterns at the same time, make sure to write `$:` before each:

$:note("<\[c2 c3\]\*4 \[bb1 bb2\]\*4 \[f2 f3\]\*4 \[eb2 eb3\]\*4>")

.sound("gm\_synth\_bass\_1").lpf(800)

$:n(\`<

\[~ 0\] 2 \[0 2\] \[~ 2\]

\[~ 0\] 1 \[0 1\] \[~ 1\]

\[~ 0\] 3 \[0 3\] \[~ 3\]

\[~ 0\] 2 \[0 2\] \[~ 2\]

>\*4\`).scale("C4:minor")

.sound("gm\_synth\_strings\_1")

$:sound("bd\*4, \[~ <sd cp>\]\*2, \[~ hh\]\*4")

.bank("RolandTR909")


This is starting to sound like actual music! We have sounds, we have notes, now the last piece of the puzzle is missing: effects

# Pattern Effects

Up until now, most of the functions we’ve seen are what other music programs are typically capable of: sequencing sounds, playing notes, controlling effects.

In this chapter, we are going to look at functions that are more unique to tidal.

**reverse patterns with rev**

n("0 1 \[4 3\] 2 0 2 \[~ 3\] 4").sound("jazz").rev()

**play pattern left and modify it right with jux**: n("0 1 \[4 3\] 2 0 2 \[~ 3\] 4").sound("jazz").jux(rev)

This is the same as:
$:n("0 1 \[4 3\] 2 0 2 \[~ 3\] 4").sound("jazz").pan(0)

$:n("0 1 \[4 3\] 2 0 2 \[~ 3\] 4").sound("jazz").pan(1).rev()


**multiple tempos**

note("c2, eb3 g3 \[bb3 c4\]").sound("piano").slow("0.5,1,1.5")

This is like doing

$:note("c2, eb3 g3 \[bb3 c4\]").s("piano").slow(0.5).color('cyan')

$:note("c2, eb3 g3 \[bb3 c4\]").s("piano").slow(1).color('magenta')

$:note("c2, eb3 g3 \[bb3 c4\]").s("piano").slow(1.5).color('yellow')


**add**

note("c2 \[eb3,g3\] ".add("<0 <1 -1>>"))

.color("<cyan <magenta yellow>>").adsr("\[.1 0\]:.2:\[1 0\]")

.sound("gm\_acoustic\_bass").room(.5).cpm(60)

If you add a number to a note, the note will be treated as if it was a number

We can add as often as we like:

note("c2 \[eb3,g3\]".add("<0 <1 -1>>").add("0,7"))

.color("<cyan <magenta yellow>>").adsr("\[.1 0\]:.2:\[1 0\]")

.sound("gm\_acoustic\_bass").room(.5).cpm(60)

**add with scale**


n("0 \[2 4\] <3 5> \[~ <4 1>\]".add("<0 \[0,2,4\]>"))

.scale("C5:minor").release(.5)

.sound("gm\_xylophone").room(.5)

**time to stack**

$:n("0 \[2 4\] <3 5> \[~ <4 1>\]".add("<0 \[0,2,4\]>"))

.scale("C5:minor")

.sound("gm\_xylophone")

.room(.4).delay(.125)

$:note("c2 \[eb3,g3\]".add("<0 <1 -1>>"))

.adsr("\[.1 0\]:.2:\[1 0\]")

.sound("gm\_acoustic\_bass")

.room(.5)

$:n("0 1 \[2 3\] 2").sound("jazz").jux(rev)

**ply**

sound("hh hh, bd rim \[~ cp\] rim").bank("RolandTR707").ply(2)

this is like writing:

sound("hh\*2 hh\*2, bd\*2 rim\*2 \[~ cp\*2\] rim\*2").bank("RolandTR707")

Try patterning the `ply` function, for example using `"<1 2 1 3>"`

**off**

n("0 \[4 <3 2>\] <2 3> \[~ 1\]"

.off(1/16,x=>x.add(4))

//.off(1/8, x=>x.add(7))

).scale("<C5:minor Db5:mixolydian>/2")

.s("triangle").room(.5).dec(.1)

In the notation `.off(1/16, x=>x.add(4))`, says:

- take the original pattern named as `x`
- modify `x` with `.add(4)`, and
- play it offset to the original pattern by `1/16` of a cycle.

off is also useful for modifying other sounds, and can even be nested:

s("bd sd \[rim bd\] sd,\[~ hh\]\*4").bank("CasioRZ1")

.off(2/16,x=>x.speed(1.5).gain(.25)

.off(3/16,y=>y.vowel("<a e i o>\*8")))

| name | description | example |
| --- | --- | --- |
| rev | reverse | 9<br>1<br>n("0 2 4 6 ~ 7 9 5").scale("C:minor").rev() |
| jux | split left/right, modify right | 9<br>1<br>n("0 2 4 6 ~ 7 9 5").scale("C:minor").jux(rev) |
| add | add numbers / notes | 9<br>1<br>n("0 2 4 6 ~ 7 9 5".add("<0 1 2 1>")).scale("C:minor") |
| ply | speed up each event n times | 9<br>1<br>s("bd sd \[~ bd\] sd").ply("<1 2 3>") |
| off | copy, shift time & modify | 9<br>1<br>s("bd sd \[~ bd\] sd, hh\*8").off(1/16,x=>x.speed(2)) |

# Samples

Samples are the most common way to make sound with tidal and strudel.
A sample is a (commonly short) piece of audio that is used as a basis for sound generation, undergoing various transformations.

# Default Samples

By default, strudel comes with a built-in “sample map”, providing a solid base to play with.
s("bd sd \[~ bd\] sd,hh\*16, misc")

Here, we are using the `s` function to play back different default samples ( `bd`, `sd`, `hh` and `misc`) to get a drum beat.

For drum sounds, strudel uses the comprehensive tidal-drum-machines library, with the following naming convention:

| Drum | Abbreviation |
| --- | --- |
| Bass drum, Kick drum | bd |
| Snare drum | sd |
| Rimshot | rim |
| Clap | cp |
| Closed hi-hat | hh |
| Open hi-hat | oh |
| Crash | cr |
| Ride | rd |
| High tom | ht |
| Medium tom | mt |
| Low tom | lt |

More percussive sounds:

| Source | Abbreviation |
| --- | --- |
| Shakers (and maracas, cabasas, etc) | sh |
| Cowbell | cb |
| Tambourine | tb |
| Other percussions | perc |
| Miscellaneous samples | misc |
| Effects | fx |


# Sound Banks

If we open the `sounds` tab and then `drum-machines`, we can see that the drum samples are all prefixed with drum machine names: `RolandTR808_bd`, `RolandTR808_sd`, `RolandTR808_hh` etc..

We _could_ use them like this:
s("RolandTR808\_bd RolandTR808\_sd,RolandTR808\_hh\*16")

but thats obviously a bit much to write. Using the `bank` function, we can shorten this to: s("bd sd,hh\*16").bank("RolandTR808")

You could even pattern the bank to switch between different drum machines: s("bd sd,hh\*16").bank("<RolandTR808 RolandTR909>")

Behind the scenes, `bank` will just prepend the drum machine name to the sample name with `_` to get the full name.
This of course only works because the name after `_` ( `bd`, `sd` etc..) is standardized.
Also note that some banks won’t have samples for all sounds!

# Selecting Sounds

If we open the `sounds` tab again, followed by tab `drum machines`, there is also a number behind each name, indicating how many individual samples are available.
For example `RolandTR909_hh(4)` means there are 4 samples of a TR909 hihat available.
By default, `s` will play the first sample, but we can select the other ones using `n`, starting from 0:
s("hh\*8").bank("RolandTR909").n("0 1 2 3")

Numbers that are too high will just wrap around to the beginning

s("hh\*8").bank("RolandTR909").n("0 1 2 3 4 5 6 7")

Here, 0-3 will play the same sounds as 4-7, because `RolandTR909_hh` only has 4 sounds.

Selecting sounds also works inside the mini notation, using “ `:`” like this: s("bd\*4,hh:0 hh:1 hh:2 hh:3 hh:4 hh:5 hh:6 hh:7") .bank("RolandTR909")


## Specifying Pitch

To make sure your samples are in tune when playing them with `note`, you can specify a base pitch like this:

samples({

'gtr':'gtr/0001\_cleanC.wav',

'moog':{'g3':'moog/005\_Mighty%20Moog%20G3.wav'},

},'github:tidalcycles/dirt-samples');

note("g3 \[bb3 c4\] <g4 f4 eb4 f3>@2").s("gtr,moog").clip(1)

.gain(.5)

We can also declare different samples for different regions of the keyboard:
samples({

'moog':{

'g2':'moog/004\_Mighty%20Moog%20G2.wav',

'g3':'moog/005\_Mighty%20Moog%20G3.wav',

'g4':'moog/006\_Mighty%20Moog%20G4.wav',

}},'github:tidalcycles/dirt-samples');

note("g2!2 <bb2 c3>!2, <c4@3 \[<eb4 bb3> g4 f4\]>")

.s('moog').clip(1)

.gain(.5).cpm(60)

The sampler will always pick the closest matching sample for the current note!

Note that this notation for pitched sounds also works inside a `strudel.json` file.

## Shabda

If you don’t want to select samples by hand, there is also the wonderful tool called [shabda](https://shabda.ndre.gr/).
With it, you can enter any sample name(s) to query from [freesound.org](https://freesound.org/). Example:

samples('shabda:bass:4,hihat:4,rimshot:2')

$:n("0 1 2 3 0 1 2 3").s('bass')

$:n("0 1\*2 2 3\*2").s('hihat').clip(1)

$:n("~ 0 ~ 1 ~ 0 0 1").s('rimshot')

You can also generate artificial voice samples with any text, in multiple languages.
Note that the language code and the gender parameters are optional and default to `en-GB` and `f`

samples('shabda/speech:the\_drum,forever')

samples('shabda/speech/fr-FR/m:magnifique')

$:s("the\_drum\*2").chop(16).speed(rand.range(0.85,1.1))

$:s("forever magnifique").slow(4).late(0.125)

# Sampler Effects

Sampler effects are functions that can be used to change the behaviour of sample playback.

### begin

a pattern of numbers from 0 to 1. Skips the beginning of each sample, e.g. `0.25` to cut off the first quarter from each sample.

- amount (number\|Pattern): between 0 and 1, where 1 is the length of the sample

samples({rave:'rave/AREUREADY.wav'},'github:tidalcycles/dirt-samples')

s("rave").begin("<0 .25 .5 .75>").fast(2)

### end

The same as .begin, but cuts off the end off each sample.

- length (number\|Pattern): 1 = whole sample, .5 = half sample, .25 = quarter sample etc..

s("bd\*2,oh\*4").end("<.1 .2 .5 1>").fast(2)

### loop

Loops the sample.
Note that the tempo of the loop is not synced with the cycle tempo.
To change the loop region, use loopBegin / loopEnd.

- on (number\|Pattern): If 1, the sample is looped

s("casio").loop(1)

### loopBegin

Synonyms: `loopb`

Begin to loop at a specific point in the sample (inbetween `begin` and `end`).
Note that the loop point must be inbetween `begin` and `end`, and before `loopEnd`!
Note: Samples starting with wt\_ will automatically loop! (wt = wavetable)

- time (number\|Pattern): between 0 and 1, where 1 is the length of the sample

s("space").loop(1)

.loopBegin("<0 .125 .25>").\_scope()

### loopEnd

Synonyms: `loope`

End the looping section at a specific point in the sample (inbetween `begin` and `end`).
Note that the loop point must be inbetween `begin` and `end`, and after `loopBegin`!

- time (number\|Pattern): between 0 and 1, where 1 is the length of the sample


s("space").loop(1)

.loopEnd("<1 .75 .5 .25>").\_scope()

### cut

In the style of classic drum-machines, `cut` will stop a playing sample as soon as another samples with in same cutgroup is to be played. An example would be an open hi-hat followed by a closed one, essentially muting the open.

- group (number\|Pattern): cut group number


s("\[oh hh\]\*4").cut(1)

### clip

Synonyms: `legato`

Multiplies the duration with the given number. Also cuts samples off at the end if they exceed the duration.

- factor (number\|Pattern):
= 0

note("c a f e").s("piano").clip("<.5 1 2>")

### loopAt

Makes the sample fit the given number of cycles by changing the speed.

samples({rhodes:'https://cdn.freesound.org/previews/132/132051\_316502-lq.mp3'})

s("rhodes").loopAt(2)

### fit

Makes the sample fit its event duration. Good for rhythmical loops like drum breaks.
Similar to `loopAt`.

samples({rhodes:'https://cdn.freesound.org/previews/132/132051\_316502-lq.mp3'})

s("rhodes/2").fit()

### chop

Cuts each sample into the given number of parts, allowing you to explore a technique known as 'granular synthesis'.
It turns a pattern of samples into a pattern of parts of samples.

samples({rhodes:'https://cdn.freesound.org/previews/132/132051\_316502-lq.mp3'})

s("rhodes")

.chop(4)

.rev()// reverse order of chops

.loopAt(2)// fit sample into 2 cycles

### striate

Cuts each sample into the given number of parts, triggering progressive portions of each sample at each loop.

s("numbers:0 numbers:1 numbers:2").striate(6).slow(3)

### slice

Chops samples into the given number of slices, triggering those slices with a given pattern of slice numbers.
Instead of a number, it also accepts a list of numbers from 0 to 1 to slice at specific points.

samples('github:tidalcycles/dirt-samples')

s("breaks165").slice(8,"0 1 <2 2\*2> 3 \[4 0\] 5 6 7".every(3,rev)).slow(0.75)

samples('github:tidalcycles/dirt-samples')

s("breaks125").fit().slice(\[0,.25,.5,.75\],"0 1 1 <2 3>")

### splice

Works the same as slice, but changes the playback speed of each slice to match the duration of its step.

samples('github:tidalcycles/dirt-samples')

s("breaks165")

.splice(8,"0 1 \[2 3 0\]@2 3 0@2 7")

### speed

Changes the speed of sample playback, i.e. a cheap way of changing pitch.

- speed (number\|Pattern): inf to inf, negative numbers play the sample backwards.

s("bd\*6").speed("1 2 4 1 -2 -4")

speed("1 1.5\*2 \[2 1.1\]").s("piano").clip(1)

After samples, let’s see what [Synths](https://strudel.cc/learn/synths/) afford us.

# Synths

In addition to the sampling engine, strudel comes with a synthesizer to create sounds on the fly.

## Basic Waveforms

The basic waveforms are `sine`, `sawtooth`, `square` and `triangle`, which can be selected via `sound` (or `s`):

note("c2 <eb2 <g2 g1>>".fast(2))

.sound("<sawtooth square triangle sine>")

.\_scope()

If you don’t set a `sound` but a `note` the default value for `sound` is `triangle`!

## Noise

You can also use noise as a source by setting the waveform to: `white`, `pink` or `brown`. These are different
flavours of noise, here written from hard to soft.

sound("<white pink brown>").\_scope()

Here’s a more musical example of how to use noise for hihats:
sound("bd\*2,<white pink brown>\*8")

.decay(.04).sustain(0).\_scope()

Some amount of pink noise can also be added to any oscillator by using the `noise` paremeter:

note("c3").noise("<0.1 0.25 0.5>").\_scope()

You can also use the `crackle` type to play some subtle noise crackles. You can control noise amount by using the `density` parameter:

s("crackle\*4").density("<0.01 0.04 0.2 0.5>".slow(2)).\_scope()

### Additive Synthesis

To tame the harsh sound of the basic waveforms, we can set the `n` control to limit the overtones of the waveform:

note("c2 <eb2 <g2 g1>>".fast(2))

.sound("sawtooth")

.n("<32 16 8 4>")

.\_scope()

When the `n` control is used on a basic waveform, it defines the number of harmonic partials the sound is getting.
You can also set `n` directly in mini notation with `sound`:

note("c2 <eb2 <g2 g1>>".fast(2))

.sound("sawtooth:<32 16 8 4>")

.\_scope()

Note for tidal users: `n` in tidal is synonymous to `note` for synths only.
In strudel, this is not the case, where `n` will always change timbre, be it though different samples or different waveforms.

## Vibrato

### vib

Synonyms: `vibrato, v`

Applies a vibrato to the frequency of the oscillator.

- frequency (number\|Pattern): of the vibrato in hertz

note("a e")

.vib("<.5 1 2 4 8 16>")

.\_scope()

// change the modulation depth with ":"

note("a e")

.vib("<.5 1 2 4 8 16>:12")

.\_scope()

### vibmod

Synonyms: `vmod`

Sets the vibrato depth in semitones. Only has an effect if `vibrato` \| `vib` \| `v` is is also set

- depth (number\|Pattern): of vibrato (in semitones)

note("a e").vib(4)

.vibmod("<.25 .5 1 2 12>")

.\_scope()

// change the vibrato frequency with ":"

note("a e")

.vibmod("<.25 .5 1 2 12>:8")

.\_scope()

## FM Synthesis

FM Synthesis is a technique that changes the frequency of a basic waveform rapidly to alter the timbre.

You can use fm with any of the above waveforms, although the below examples all use the default triangle wave.

### fm

Synonyms: `fmi`

Sets the Frequency Modulation of the synth.
Controls the modulation index, which defines the brightness of the sound.

- brightness (number\|Pattern): modulation index

note("c e g b g e")

.fm("<0 1 2 8 32>")

.\_scope()

### fmh

Sets the Frequency Modulation Harmonicity Ratio.
Controls the timbre of the sound.
Whole numbers and simple ratios sound more natural,
while decimal numbers and complex ratios sound metallic.

- harmonicity (number\|Pattern):

note("c e g b g e")

.fm(4)

.fmh("<1 2 1.5 1.61>")

.\_scope()

### fmattack

Attack time for the FM envelope: time it takes to reach maximum modulation

- time (number\|Pattern): attack time

note("c e g b g e")

.fm(4)

.fmattack("<0 .05 .1 .2>")

.\_scope()

### fmdecay

Decay time for the FM envelope: seconds until the sustain level is reached after the attack phase.

- time (number\|Pattern): decay time

note("c e g b g e")

.fm(4)

.fmdecay("<.01 .05 .1 .2>")

.fmsustain(.4)

.\_scope()

### fmsustain

Sustain level for the FM envelope: how much modulation is applied after the decay phase

- level (number\|Pattern): sustain level

note("c e g b g e")

.fm(4)

.fmdecay(.1)

.fmsustain("<1 .75 .5 0>")

.\_scope()

### fmenv

Ramp type of fm envelope. Exp might be a bit broken..

- type (number\|Pattern): lin \| exp

note("c e g b g e")

.fm(4)

.fmdecay(.2)

.fmsustain(0)

.fmenv("<exp lin>")

.\_scope()

## Wavetable Synthesis

Strudel can also use the sampler to load custom waveforms as a replacement of the default waveforms used by WebAudio for the base synth. A default set of more than 1000 wavetables is accessible by default (coming from the [AKWF](https://www.adventurekid.se/akrt/waveforms/adventure-kid-waveforms/) set). You can also import/use your own. A wavetable is a one-cycle waveform, which is then repeated to create a sound at the desired frequency. It is a classic but very effective synthesis technique.

Any sample preceded by the `wt_` prefix will be loaded as a wavetable. This means that the `loop` argument will be set to `1` by default. You can scan over the wavetable by using `loopBegin` and `loopEnd` as well.

samples('bubo:waveforms');

note("<\[g3,b3,e4\]!2 \[a3,c3,e4\] \[b3,d3,f#4\]>")

.n("<1 2 3 4 5 6 7 8 9 10>/2").room(0.5).size(0.9)

.s('wt\_flute').velocity(0.25).often(n=>n.ply(2))

.release(0.125).decay("<0.1 0.25 0.3 0.4>").sustain(0)

.cutoff(2000).cutoff("<1000 2000 4000>").fast(4)

.\_scope()

## ZZFX

The “Zuper Zmall Zound Zynth” [ZZFX](https://github.com/KilledByAPixel/ZzFX) is also integrated in strudel.
Developed by [Frank Force](https://frankforce.com/), it is a synth and FX engine originally intended to be used for size coding games.

It has 20 parameters in total, here is a snippet that uses all:

note("c2 eb2 f2 g2")// also supports freq

.s("{z\_sawtooth z\_tan z\_noise z\_sine z\_square}%4")

.zrand(0)// randomization

// zzfx envelope

.attack(0.001)

.decay(0.1)

.sustain(.8)

.release(.1)

// special zzfx params

.curve(1)// waveshape 1-3

.slide(0)// \+/\- pitch slide

.deltaSlide(0)// \+/\- pitch slide (?)

.noise(0)// make it dirty

.zmod(0)// fm speed

.zcrush(0)// bit crush 0 - 1

.zdelay(0)// simple delay

.pitchJump(0)// \+/\- pitch change after pitchJumpTime

.pitchJumpTime(0)// >0 time after pitchJump is applied

.lfo(0)// >0 resets slide + pitchJump + sets tremolo speed

.tremolo(0)// 0-1 lfo volume modulation amount

//.duration(.2) // overwrite strudel event duration

//.gain(1) // change volume

.\_scope()// vizualise waveform (not zzfx related)

# Audio Effects

Whether you’re using a synth or a sample, you can apply any of the following built-in audio effects.
As you might suspect, the effects can be chained together, and they accept a pattern string as their argument.

## Filters

Filters are an essential building block of subtractive synthesis
Strudel comes with 3 types of filters:

- low-pass filter: low frequencies may _pass_, high frequencies are cut off
- high-pass filter: high frequencies may _pass_, low frequencies are cut off
- band-pass filters: only a frequency band may _pass_, low and high frequencies around are cut off

Each filter has 2 parameters:

- cutoff: the frequency at which the filter starts to work. e.g. a low-pass filter with a cutoff of 1000Hz allows frequencies below 1000Hz to pass.
- q-value: Controls the resonance of the filter. Higher values sound more aggressive. 

## lpf

Synonyms: `cutoff, ctf, lp`

Applies the cutoff frequency of the **l** ow- **p** ass **f** ilter.

When using mininotation, you can also optionally add the 'lpq' parameter, separated by ':'.

- frequency (number\|Pattern): audible between 0 and 20000
s("bd sd \[~ bd\] sd,hh\*6").lpf("<4000 2000 1000 500 200 100>")
s("bd\*16").lpf("1000:0 1000:10 1000:20 1000:30")

## lpq

Synonyms: `resonance`

Controls the **l** ow- **p** ass **q**-value.

- q (number\|Pattern): resonance factor between 0 and 50

s("bd sd \[~ bd\] sd,hh\*8").lpf(2000).lpq("<0 10 20 30>")

## hpf

Synonyms: `hp, hcutoff`

Applies the cutoff frequency of the **h** igh- **p** ass **f** ilter.

When using mininotation, you can also optionally add the 'hpq' parameter, separated by ':'.

- frequency (number\|Pattern): audible between 0 and 20000

s("bd sd \[~ bd\] sd,hh\*8").hpf("<4000 2000 1000 500 200 100>")

s("bd sd \[~ bd\] sd,hh\*8").hpf("<2000 2000:25>")

## hpq

Synonyms: `hresonance`

Controls the **h** igh- **p** ass **q**-value.

- q (number\|Pattern): resonance factor between 0 and 50

s("bd sd \[~ bd\] sd,hh\*8").hpf(2000).hpq("<0 10 20 30>")

## bpf

Synonyms: `bandf, bp`

Sets the center frequency of the **b** and- **p** ass **f** ilter. When using mininotation, you
can also optionally supply the 'bpq' parameter separated by ':'.

- frequency (number\|Pattern): center frequency

s("bd sd \[~ bd\] sd,hh\*6").bpf("<1000 2000 4000 8000>")

## bpq

Synonyms: `bandq`

Sets the **b** and- **p** ass **q**-factor (resonance).

- q (number\|Pattern): q factor
s("bd sd \[~ bd\] sd").bpf(500).bpq("<0 1 2 3>")

## ftype

Sets the filter type. The ladder filter is more aggressive. More types might be added in the future.

- type (number\|Pattern): 12db (0), ladder (1), or 24db (2)
note("{f g g c d a a#}%8").s("sawtooth").lpenv(4).lpf(500).ftype("<0 1 2>").lpq(1)

note("c f g g a c d4").fast(2)

.sound('sawtooth')

.lpf(200).fanchor(0)

.lpenv(3).lpq(1)

.ftype("<ladder 12db 24db>")

## vowel

Formant filter to make things sound like vowels.

- vowel (string\|Pattern): You can use a e i o u ae aa oe ue y uh un en an on, corresponding to \[a\] \[e\] \[i\] \[o\] \[u\] \[æ\] \[ɑ\] \[ø\] \[y\] \[ɯ\] \[ʌ\] \[œ̃\] \[ɛ̃\] \[ɑ̃\] \[ɔ̃\]. Aliases: aa = å = ɑ, oe = ø = ö, y = ı, ae = æ.

note("\[c2 <eb2 <g2 g1>>\]\*2").s('sawtooth')

.vowel("<a e i <o u>>")

s("bd sd mt ht bd \[~ cp\] ht lt").vowel("\[a\|e\|i\|o\|u\]")

# Amplitude Envelope

The amplitude envelope controls the dynamic contour of a sound.
Strudel uses ADSR envelopes, which are probably the most common way to describe an envelope:

## attack

Synonyms: `att`

Amplitude envelope attack time: Specifies how long it takes for the sound to reach its peak value, relative to the onset.

- attack (number\|Pattern): time in seconds.

note("c3 e3 f3 g3").attack("<0 .1 .5>")

## decay

Amplitude envelope decay time: the time it takes after the attack time to reach the sustain level.
Note that the decay is only audible if the sustain value is lower than 1.

- time (number\|Pattern): decay time in seconds
note("c3 e3 f3 g3").decay("<.1 .2 .3 .4>").sustain(0)

## sustain

Synonyms: `sus`

Amplitude envelope sustain level: The level which is reached after attack / decay, being sustained until the offset.

- gain (number\|Pattern): sustain level between 0 and 1

note("c3 e3 f3 g3").decay(.2).sustain("<0 .1 .4 .6 1>")

## release

Synonyms: `rel`

Amplitude envelope release time: The time it takes after the offset to go from sustain level to zero.

- time (number\|Pattern): release time in seconds

note("c3 e3 g3 c4").release("<0 .1 .4 .6 1>/2")

## adsr

ADSR envelope: Combination of Attack, Decay, Sustain, and Release.

- time (number\|Pattern): attack time in seconds
- time (number\|Pattern): decay time in seconds
- gain (number\|Pattern): sustain level (0 to 1)
- time (number\|Pattern): release time in seconds

note("\[c3 bb2 f3 eb3\]\*2").sound("sawtooth").lpf(600).adsr(".1:.1:.5:.2")

# Filter Envelope

Each filter can receive an additional filter envelope controlling the cutoff value dynamically. It uses an ADSR envelope similar to the one used for amplitude. There is an additional parameter to control the depth of the filter modulation: `lpenv` \| `hpenv` \| `bpenv`. This allows you to play subtle or huge filter modulations just the same by only increasing or decreasing the depth.

note("\[c eb g <f bb>\](3,8,<0 1>)".sub(12))

.s("<sawtooth>/64")

.lpf(sine.range(300,2000).slow(16))

.lpa(0.005)

.lpd(perlin.range(.02,.2))

.lps(perlin.range(0,.5).slow(3))

.lpq(sine.range(2,10).slow(32))

.release(.5)

.lpenv(perlin.range(1,8).slow(2))

.ftype('24db')

.room(1)

.juxBy(.5,rev)

.sometimes(add(note(12)))

.stack(s("bd\*2").bank('RolandTR909'))

.gain(.5).fast(2)

There is one filter envelope for each filter type and thus one set of envelope filter parameters preceded either by `lp`, `hp` or `bp`:

- `lpattack`, `lpdecay`, `lpsustain`, `lprelease`, `lpenv`: filter envelope for the lowpass filter.

  - alternatively: `lpa`, `lpd`, `lps`, `lpr` and `lpe`.
- `hpattack`, `hpdecay`, `hpsustain`, `hprelease`, `hpenv`: filter envelope for the highpass filter.

  - alternatively: `hpa`, `hpd`, `hps`, `hpr` and `hpe`.
- `bpattack`, `bpdecay`, `bpsustain`, `bprelease`, `bpenv`: filter envelope for the bandpass filter.

  - alternatively: `bpa`, `bpd`, `bps`, `bpr` and `bpe`.

## lpattack

Synonyms: `lpa`

Sets the attack duration for the lowpass filter envelope.

- attack (number\|Pattern): time of the filter envelope

note("c2 e2 f2 g2")

.sound('sawtooth')

.lpf(300)

.lpa("<.5 .25 .1 .01>/4")

.lpenv(4)

## lpdecay

Synonyms: `lpd`

Sets the decay duration for the lowpass filter envelope.

- decay (number\|Pattern): time of the filter envelope

note("c2 e2 f2 g2")

.sound('sawtooth')

.lpf(300)

.lpd("<.5 .25 .1 0>/4")

.lpenv(4)

## lpsustain

Synonyms: `lps`

Sets the sustain amplitude for the lowpass filter envelope.

- sustain (number\|Pattern): amplitude of the lowpass filter envelope

note("c2 e2 f2 g2")

.sound('sawtooth')

.lpf(300)

.lpd(.5)

.lps("<0 .25 .5 1>/4")

.lpenv(4)

## lprelease

Synonyms: `lpr`

Sets the release time for the lowpass filter envelope.

- release (number\|Pattern): time of the filter envelope

note("c2 e2 f2 g2")

.sound('sawtooth')

.clip(.5)

.lpf(300)

.lpenv(4)

.lpr("<.5 .25 .1 0>/4")

.release(.5)

## lpenv

Synonyms: `lpe`

Sets the lowpass filter envelope modulation depth.

- modulation (number\|Pattern): depth of the lowpass filter envelope between 0 and n

note("c2 e2 f2 g2")

.sound('sawtooth')

.lpf(300)

.lpa(.5)

.lpenv("<4 2 1 0 -1 -2 -4>/4")

# Pitch Envelope

You can also control the pitch with envelopes!
Pitch envelopes can breathe life into static sounds:

n("<-4,0 5 2 1>\*<2!3 4>")

.scale("<C F>/8:pentatonic")

.s("gm\_electric\_guitar\_jazz")

.penv("<.5 0 7 -2>\*2").vib("4:.1")

.phaser(2).delay(.25).room(.3)

.size(4).fast(1.5)

You also create some lovely chiptune-style sounds:

n(run("<4 8>/16")).jux(rev)

.chord("<C^7 <Db^7 Fm7>>")

.dict('ireal')

.voicing().add(note("<0 1>/8"))

.dec(.1).room(.2)

.segment("<4 \[2 8\]>")

.penv("<0 <2 -2>>").patt(.02).fast(2)

Let’s break down all pitch envelope controls:

## pattack

Synonyms: `patt`

Attack time of pitch envelope.

- time (number\|Pattern): time in seconds

note("c eb g bb").pattack("0 .1 .25 .5").slow(2)

## pdecay

Synonyms: `pdec`

Decay time of pitch envelope.

- time (number\|Pattern): time in seconds

note("<c eb g bb>").pdecay("<0 .1 .25 .5>")

## prelease

Synonyms: `prel`

Release time of pitch envelope

- time (number\|Pattern): time in seconds

note("<c eb g bb> ~")

.release(.5)// to hear the pitch release

.prelease("<0 .1 .25 .5>")

## penv

Amount of pitch envelope. Negative values will flip the envelope.
If you don't set other pitch envelope controls, `pattack:.2` will be the default.

- semitones (number\|Pattern): change in semitones

note("c")

.penv("<12 7 1 .5 0 -1 -7 -12>")

## pcurve

Curve of envelope. Defaults to linear. exponential is good for kicks

- type (number\|Pattern): 0 = linear, 1 = exponential


note("g1\*4")

.s("sine").pdec(.5)

.penv(32)

.pcurve("<0 1>")

## panchor

Sets the range anchor of the envelope:

- anchor 0: range = \[note, note + penv\]
- anchor 1: range = \[note - penv, note\]
If you don't set an anchor, the value will default to the psustain value.

- anchor (number\|Pattern): anchor offset

note("c c4").penv(12).panchor("<0 .5 1 .5>")

# Dynamics

## gain

Controls the gain by an exponential amount.

- amount (number\|Pattern): gain.

s("hh\*8").gain(".4!2 1 .4!2 1 .4 1").fast(2)

## velocity

Sets the velocity from 0 to 1. Is multiplied together with gain.

s("hh\*8")

.gain(".4!2 1 .4!2 1 .4 1")

.velocity(".4 1")

## compressor

Dynamics Compressor. The params are `compressor("threshold:ratio:knee:attack:release")`
s("bd sd \[~ bd\] sd,hh\*8")

.compressor("-20:20:10:.002:.02")

## postgain

Gain applied after all effects have been processed.


s("bd sd \[~ bd\] sd,hh\*8")

.compressor("-20:20:10:.002:.02").postgain(1.5)

## xfade

Cross-fades between left and right from 0 to 1:

- 0 = (full left, no right)
- .5 = (both equal)
- 1 = (no left, full right)

xfade(s("bd\*2"),"<0 .25 .5 .75 1>",s("hh\*8"))

# Panning

## jux

The jux function creates strange stereo effects, by applying a function to a pattern, but only in the right-hand channel.

s("bd lt \[~ ht\] mt cp ~ bd hh").jux(rev)

s("bd lt \[~ ht\] mt cp ~ bd hh").jux(press)


s("bd lt \[~ ht\] mt cp ~ bd hh").jux(iter(4))

## juxBy

Synonyms: `juxby`

Jux with adjustable stereo width. 0 = mono, 1 = full stereo.

s("bd lt \[~ ht\] mt cp ~ bd hh").juxBy("<0 .5 1>/2",rev)

## pan

Sets position in stereo.

- pan (number\|Pattern): between 0 and 1, from left to right (assuming stereo), once round a circle (assuming multichannel)

s("\[bd hh\]\*2").pan("<.5 1 .5 0>")

s("bd rim sd rim bd ~ cp rim").pan(sine.slow(2))

# Waveshaping

## coarse

fake-resampling for lowering the sample rate. Caution: This effect seems to only work in chromium based browsers

- factor (number\|Pattern): 1 for original 2 for half, 3 for a third and so on.

s("bd sd \[~ bd\] sd,hh\*8").coarse("<1 4 8 16 32>")

## crush

bit crusher effect.

- depth (number\|Pattern): between 1 (for drastic reduction in bit-depth) to 16 (for barely no reduction).

s("<bd sd>,hh\*3").fast(2).crush("<16 8 7 6 5 4 3 2>")

## distort

Synonyms: `dist`

Wave shaping distortion. CAUTION: it can get loud.
Second option in optional array syntax (ex: ".9:.5") applies a postgain to the output.
Most useful values are usually between 0 and 10 (depending on source gain). If you are feeling adventurous, you can turn it up to 11 and beyond ;)

- distortion (number\|Pattern):

s("bd sd \[~ bd\] sd,hh\*8").distort("<0 2 3 10:.5>")
note("d1!8").s("sine").penv(36).pdecay(.12).decay(.23).distort("8:.4")

# Global Effects

## Local vs Global Effects

While the above listed “local” effects will always create a separate effects chain for each event,
global effects use the same chain for all events of the same orbit:

## orbit

An `orbit` is a global parameter context for patterns. Patterns with the same orbit will share the same global effects.

- number (number\|Pattern):
stack(

s("hh\*6").delay(.5).delaytime(.25).orbit(1),

s("~ sd ~ sd").delay(.5).delaytime(.125).orbit(2)

)

## Delay

### delay

Sets the level of the delay signal.

When using mininotation, you can also optionally add the 'delaytime' and 'delayfeedback' parameter,
separated by ':'.

- level (number\|Pattern): between 0 and 1

s("bd bd").delay("<0 .25 .5 1>")

s("bd bd").delay("0.65:0.25:0.9 0.65:0.125:0.7")

### delaytime

Synonyms: `delayt, dt`

Sets the time of the delay effect.

- seconds (number\|Pattern): between 0 and Infinity

s("bd bd").delay(.25).delaytime("<.125 .25 .5 1>")

### delayfeedback

Synonyms: `delayfb, dfb`

Sets the level of the signal that is fed back into the delay.
Caution: Values >= 1 will result in a signal that gets louder and louder! Don't do it

- feedback (number\|Pattern): between 0 and 1

s("bd").delay(.25).delayfeedback("<.25 .5 .75 1>")

## Reverb

### room

Sets the level of reverb.

When using mininotation, you can also optionally add the 'size' parameter, separated by ':'.

- level (number\|Pattern): between 0 and 1

s("bd sd \[~ bd\] sd").room("<0 .2 .4 .6 .8 1>")

s("bd sd \[~ bd\] sd").room("<0.9:1 0.9:4>")

### roomsize

Synonyms: `rsize, sz, size`

Sets the room size of the reverb, see `room`.
When this property is changed, the reverb will be recaculated, so only change this sparsely..

- size (number\|Pattern): between 0 and 10

s("bd sd \[~ bd\] sd").room(.8).rsize(1)

s("bd sd \[~ bd\] sd").room(.8).rsize(4)

### roomfade

Synonyms: `rfade`

Reverb fade time (in seconds).
When this property is changed, the reverb will be recaculated, so only change this sparsely..

- seconds (number): for the reverb to fade

s("bd sd \[~ bd\] sd").room(0.5).rlp(10000).rfade(0.5)

s("bd sd \[~ bd\] sd").room(0.5).rlp(5000).rfade(4)

### roomlp

Synonyms: `rlp`

Reverb lowpass starting frequency (in hertz).
When this property is changed, the reverb will be recaculated, so only change this sparsely..

- frequency (number): between 0 and 20000hz

s("bd sd \[~ bd\] sd").room(0.5).rlp(10000)
s("bd sd \[~ bd\] sd").room(0.5).rlp(5000)

### roomdim

Synonyms: `rdim`

Reverb lowpass frequency at -60dB (in hertz).
When this property is changed, the reverb will be recaculated, so only change this sparsely..

- frequency (number): between 0 and 20000hz

s("bd sd \[~ bd\] sd").room(0.5).rlp(10000).rdim(8000)


s("bd sd \[~ bd\] sd").room(0.5).rlp(5000).rdim(400)

### iresponse

Synonyms: `ir`

Sets the sample to use as an impulse response for the reverb.

- sample (string\|Pattern): to use as an impulse response


s("bd sd \[~ bd\] sd").room(.8).ir("<shaker\_large:0 shaker\_large:2>")

## Phaser

### phaser

Synonyms: `ph`

Phaser audio effect that approximates popular guitar pedals.

- speed (number\|Pattern): speed of modulation
n(run(8)).scale("D:pentatonic").s("sawtooth").release(0.5)

.phaser("<1 2 4 8>")

### phaserdepth

Synonyms: `phd`

The amount the signal is affected by the phaser effect. Defaults to 0.75

- depth (number\|Pattern): number between 0 and 1
n(run(8)).scale("D:pentatonic").s("sawtooth").release(0.5)

.phaser(2).phaserdepth("<0 .5 .75 1>")

### phasercenter

Synonyms: `phc`

The center frequency of the phaser in HZ. Defaults to 1000

- centerfrequency (number\|Pattern): in HZ

n(run(8)).scale("D:pentatonic").s("sawtooth").release(0.5)

.phaser(2).phasercenter("<800 2000 4000>")

### phasersweep

Synonyms: `phs`

The frequency sweep range of the lfo for the phaser effect. Defaults to 2000

- phasersweep (number\|Pattern): most useful values are between 0 and 4000

n(run(8)).scale("D:pentatonic").s("sawtooth").release(0.5)

.phaser(2).phasersweep("<800 2000 4000>")

# Recipes

This page shows possible ways to achieve common (or not so common) musical goals.
There are often many ways to do a thing and there is no right or wrong.
The fun part is that each representation will give you different impulses when improvising.

## Arpeggios

An arpeggio is when the notes of a chord are played in sequence.
We can either write the notes by hand:

note("c eb g c4")

.clip(2).s("gm\_electric\_guitar\_clean")

…or use scales:

n("0 2 4 7").scale("C:minor")

.clip(2).s("gm\_electric\_guitar\_clean")

…or chord symbols:

n("0 1 2 3").chord("Cm").mode("above:c3").voicing()

.clip(2).s("gm\_electric\_guitar\_clean")

…using off:

"0"

.off(1/3,add(2))

.off(1/2,add(4))

.n()

.scale("C:minor")

.s("gm\_electric\_guitar\_clean")

## Chopping Breaks

A sample can be looped and chopped like this:

samples('github:yaxu/clean-breaks')

s("amen/4").fit().chop(32)

This fits the break into 8 cycles + chops it in 16 pieces.
The chops are not audible yet, because we’re not doing any manipulation.
Let’s add randmized doubling + reversing:

samples('github:yaxu/clean-breaks')

s("amen/4").fit().chop(16).cut(1)

.sometimesBy(.5,ply("2"))

.sometimesBy(.25,mul(speed("-1")))

If we want to specify the order of samples, we can replace `chop` with `slice`:

samples('github:yaxu/clean-breaks')

s("amen/4").fit()

.slice(8,"<0 1 2 3 4\*2 5 6 \[6 7\]>\*2")

.cut(1).rarely(ply("2"))

If we use `splice` instead of `slice`, the speed adjusts to the duration of the event:

samples('github:yaxu/clean-breaks')

s("amen")

.splice(8,"<0 1 2 3 4\*2 5 6 \[6 7\]>\*2")

.cut(1).rarely(ply("2"))

Note that we don’t need `fit`, because `splice` will do that by itself.

## Filter Envelopes

Using `lpenv`, we can make the filter move:

note("g1 bb1 <c2 eb2> d2")

.s("sawtooth")

.lpf(400).lpenv(4)

.scope()

The type of envelope depends on the methods you’re setting. Let’s set `lpa`:

note("g1 bb1 <c2 eb2> d2")

.s("sawtooth").lpq(8)

.lpf(400).lpa(.2).lpenv(4)

.scope()

Now the filter is attacking, rather than decaying as before (decay is the default). We can also do both

note("g1 bb1 <c2 eb2> d2")

.s("sawtooth").lpq(8)

.lpf(400).lpa(.1).lpd(.1).lpenv(4)

.scope()

You can play around with `lpa` \| `lpd` \| `lps` \| `lpd` to see what the filter envelope will do.

## Layering Sounds

We can layer sounds by separating them with ”,”:
note("<g1 bb1 d2 f1>")

.s("sawtooth, square")// <------

.scope()

We can control the gain of individual sounds like this:

note("<g1 bb1 d2 f1>")

.s("sawtooth, square:0:.5")// <\-\-\- "name:number:gain"

.scope()

For more control over each voice, we can use `layer`:

note("<g1 bb1 d2 f1>").layer(

x=>x.s("sawtooth").vib(4),

x=>x.s("square").add(note(12))

).scope()

Here, we give the sawtooth a vibrato and the square is moved an octave up.
With `layer`, you can use any pattern method available on each voice, so sky is the limit..

## Oscillator Detune

We can fatten a sound by adding a detuned version to itself:

note("<g1 bb1 d2 f1>")

.add(note("0,.1"))// <\-\-\-\-\-\- chorus

.s("sawtooth").scope()

Try out different values, or add another voice!

## Polyrhythms

Here is a simple example of a polyrhythm:


s("bd\*2,hh\*3")

A polyrhythm is when 2 different tempos happen at the same time.

## Polymeter

This is a polymeter:

s("<bd rim, hh hh oh>\*4")

A polymeter is when 2 different bar lengths play at the same tempo.

## Phasing

This is a phasing:

note("<C D G A Bb D C A G D Bb A>\*\[6,6.1\]").piano()

Phasing happens when the same sequence plays at slightly different tempos.

## Running through samples

Using `run` with `n`, we can rush through a sample bank:

samples('bubo:fox')

n(run(8)).s("ftabla")

This works great with sample banks that contain similar sounds, like in this case different recordings of a tabla.
Often times, you’ll hear the beginning of the phrase not where the pattern begins.
In this case, I hear the beginning at the third sample, which can be accounted for with `early`.


samples('bubo:fox')

n(run(8)).s("ftabla").early(2/8)

Let’s add some randomness:


samples('bubo:fox')

n(run(8)).s("ftabla").early(2/8)

.sometimes(mul(speed("1.5")))

## Tape Warble

We can emulate a pitch warbling effect like this:


note("<c4 bb f eb>\*8")

.add(note(perlin.range(0,.5)))// <\-\-\-\-\-\- warble

.clip(2).s("gm\_electric\_guitar\_clean")

## Sound Duration

There are a number of ways to change the sound duration. Using clip:

note("f ab bb c")

.clip("<2 1 .5 .25>")

The value of clip is relative to the duration of each event.
We can also create overlaps using release:

note("f ab bb c")

.release("<2 1 .5 .25>")

This will smoothly fade out each sound for the given number of seconds.
We could also make the notes shorter by using a decay envelope:

note("f ab bb c")

.decay("<2 1 .5 .25>")

When using samples, we also have `.end` to cut relative to the sample length:


s("oh\*4").end("<1 .5 .25 .1>")

Compare that to clip:

s("oh\*4").clip("<1 .5 .25 .1>")

or decay:

s("oh\*4").decay("<1 .5 .25 .1>")

## Wavetable Synthesis

You can loop a sample with `loop` / `loopEnd`:
note("<c eb g f>").s("bd").loop(1).loopEnd(.05).gain(.2)

This allows us to play the first 5% of the bass drum as a synth!
To simplify loading wavetables, any sample that starts with `wt_` will be looped automatically:

samples('github:bubobubobubobubo/dough-waveforms')

note("c eb g bb").s("wt\_dbass").clip(2)

Running through different wavetables can also give interesting variations:

samples('github:bubobubobubobubo/dough-waveforms')

note("c2\*8").s("wt\_dbass").n(run(8)).fast(2)

…adding a filter envelope + reverb:

samples('github:bubobubobubobubo/dough-waveforms')

note("c2\*8").s("wt\_dbass").n(run(8))

.lpf(perlin.range(100,1000).slow(8))

.lpenv(-3).lpa(.1).room(.5).fast(2)


# Metadata
You can optionally add some music metadata in your Strudel code, by using tags in code comments:

// @title Hey Hoo
// @by Sam Tagada
// @license CC BY-NC-SA
Like other comments, those are ignored by Strudel, but it can be used by other tools to retrieve some information about the music.
Available tags are:
@title: music title
@by: music author(s)
@details: some additional information about the music
@genre: music genre(s) (pop, jazz, etc)

**Strudel Visual Feedback Cheatsheet**
*(inline = `_function()`, background = `function()`)*

---

# Mini-notation Highlighting

```js
n("<0 2 1 3 2>*8").scale("<A1 D2>/4:minor:pentatonic")
.s("supersaw").lpf(300).lpenv("<4 3 2>*4").color("cyan magenta")
```

* Wrap mini-notation in `" "` or \` \` to auto-highlight.
* `.color("…")` (space-separated list → patterned colors).

---

### Punchcard / Pianoroll

```js
note("c a f e").color("white")._punchcard({cycles:4, labels:1})
```

* **Punchcard** shows *post-transform* pattern (lightweight).
* **Pianoroll** shows raw notes.
* Key opts: `cycles`, `playhead`, `labels`, `flipTime`, `flipValues`,
  `active`, `inactive`, `smear`, `hideInactive`.

---

### Spiral

```js
note("c2 a2 eb2").euclid(5,8)._spiral({steady:.96, stretch:1})
```

* Visual spiral of timeline.
* Useful opts: `stretch`, `size`, `thickness`, `steady`, `logSpiral`, `fade`.

---

### Scope (oscilloscope)

```js
s("sawtooth")._scope({align:1, thickness:3, scale:0.25})
```

* Time-domain view.
* Main opts: `align`, `color`, `thickness`, `scale`, `trigger`.

---

### Pitchwheel

```js
n("0 .. 12").scale("C:chromatic").s("saw")._pitchwheel({edo:12, root:"C"})
```

* One-octave pitch circle.
* Core opts: `edo`, `root`, `thickness`, `mode`.

---

### Spectrum

```js
s("sine").dec(.3).room(.5)._spectrum({min:-80, max:0, speed:1})
```

* Frequency analyzer.
* Opts: `min`, `max`, `speed`, `thickness`.

---

### markcss

```js
note("c a f e").markcss('text-decoration:underline')
```

* Override CSS of highlighted events (single quotes).

---

#### Global vs. Inline

| Visual call            | Where it appears                     |
| ---------------------- | ------------------------------------ |
| `pattern.punchcard()`  | full-page background                 |
| `pattern._punchcard()` | inside code block (multiple allowed) |

Use this sheet to pick a visual, add `_` for inline, and tweak the handful of options you actually need.

# Drum machines
akaimpc60_bd(2) akaimpc60_sd(3)
alesissr16_bd(13) alesissr16_sd(12)
bossdr110_bd(1) bossdr110_sd(1)
drumulator_bd(1) drumulator_sd(1)
emusp12_bd(14) emusp12_sd(21)
linndrum_bd(1) linndrum_sd(3)
linnlm1_bd(4) linnlm1_sd(1)
linnlm2_bd(4) linnlm2_sd(4)
oberheimdmx_bd(3) oberheimdmx_sd(3)
rolandtr505_bd(1) rolandtr505_sd(1)
rolandtr606_bd(1) rolandtr606_sd(1)
rolandtr707_bd(2) rolandtr707_sd(2)
rolandtr727_perc(10)
rolandtr808_bd(25) rolandtr808_sd(25)
rolandtr909_bd(4) rolandtr909_sd(16)
yamaharx5_bd(2) yamaharx5_sd(3)
yamahary30_bd(13) yamahary30_sd(21)
mpc1000_bd(5) mpc1000_sd(4)
sr16_bd(13) sr16_sd(12)
ddr30_bd(8) ddr30_sd(8)
sp12_bd(14) sp12_sd(21)
dr550_bd(5) dr550_sd(6)
mc303_bd(16) mc303_sd(26)

# synths
sine square sawtooth triangle supersaw pulse white pink
gm_lead_1_square(3) gm_lead_2_sawtooth(7) gm_lead_5_charang(10)
gm_synth_bass_1(10) gm_synth_bass_2(7)
gm_pad_new_age(12) gm_pad_warm(7) gm_pad_sweep(7)
gm_string_ensemble_1(11) gm_voice_oohs(6)
gm_piano(32)
gm_epiano1(11) gm_epiano2(9)
gm_choir_aahs(9)
gm_violin(9) gm_cello(6)
gm_flute(5) gm_clarinet(6) gm_oboe(5)
gm_acoustic_guitar_steel(10) gm_distortion_guitar(7)
gm_overdriven_guitar(10)

# samples
agogo(5) anvil(9) balafon(6) balafon_hard(6) balafon_soft(6) ballwhistle(2) bassdrum1(8) bassdrum2(30) belltree(6) bongo(28) brakedrum(17) cabasa(6) cajon(18) casio(3) clap(10) clash(10) clash2(5) clave(6) clavisynth(19) conga(34) cowbell(13) crow(4) dantranh(17) dantranh_tremolo(16) dantranh_vibrato(16) darbuka(20) didgeridoo(12) east(9) fingercymbal(1) flexatone(8) fmpiano(22) folkharp(29) framedrum(18) glockenspiel(7) gong(7) gong2(6) guiro(5) handbells(3) handchimes(19) harmonica(9) harmonica_soft(10) harmonica_vib(10) harp(23) hihat(15) insect(3) jazz(8) kalimba(11) kalimba2(25) kalimba3(22) kalimba4(22) kalimba5(14) kawai(37) marimba(10) marktrees(6) metal(10) num(21) numbers(9) ocarina(11) ocarina_small(10) ocarina_small_stacc(13) ocarina_vib(10) oceandrum(3) organ_4inch(27) organ_8inch(27) organ_full(27) piano(29) piano1(22) pipeorgan_loud(21) pipeorgan_loud_pedal(11) pipeorgan_quiet(21) pipeorgan_quiet_pedal(11) psaltery_bow(11) psaltery_pluck(11) psaltery_spiccato(11) ratchet(8) recorder_alto_stacc(12) recorder_alto_sus(12) recorder_alto_vib(12) recorder_bass_stacc(15) recorder_bass_sus(12) recorder_bass_vib(14) recorder_soprano_stacc(12) recorder_soprano_sus(13) recorder_tenor_stacc(12) recorder_tenor_sus(13) recorder_tenor_vib(14) sax(23) sax_stacc(23) sax_vib(19) saxello(8) saxello_stacc(8) saxello_vib(8) shaker_large(6) shaker_small(16) siren(5) slapstick(5) sleighbells(6) slitdrum(6) snare_hi(8) snare_low(20) snare_modern(72) snare_rim(4) space(18) steinway(42) strumstick(19) super64(13) super64_acc(13) super64_vib(13) sus_cymbal(25) sus_cymbal2(23) tambourine(7) tambourine2(7) timpani(30) timpani_roll(10) timpani2(204) tom_mallet(8) tom_rim(6) tom_stick(8) tom2_mallet(8) tom2_rim(6) tom2_stick(8) trainwhistle(6) triangles(37) tubularbells(9) tubularbells2(11) vibraphone(11) vibraphone_bowed(6) vibraphone_soft(11) vibraslap(4) wind(10) wineglass(4) wineglass_slow(4) woodblock(10) xylophone_hard_ff(8) xylophone_hard_pp(8) xylophone_medium_ff(8) xylophone_medium_pp(8) xylophone_soft_ff(8) xylophone_soft_pp(8)

# Examples
```
// "acidic tooth" @by eddyflux
// @version 1.0
  setcps(1)
  stack(
    note("[<g1 f1>/8](<3 5>,8)")
    .clip(perlin.range(.15,1.5))
    .release(.1)
    .s("sawtooth")
    .lpf(sine.range(400,800).slow(16))
    .lpq(cosine.range(6,14).slow(3))
    .lpenv(sine.mul(4).slow(4))
    .lpd(.2).lpa(.02)
    .ftype('24db')
    .rarely(add(note(12)))
    .room(.2).shape(.3).postgain(.5)
    .superimpose(x=>x.add(note(12)).delay(.5).bpf(1000))
    .gain("[.2 1@3]*2") // fake sidechain
    ,
    stack(
      s("bd*2").mask("<0@4 1@16>"),
      s("hh*8").gain(saw.mul(saw.fast(2))).clip(sine)
      .mask("<0@8 1@16>")
    ).bank('RolandTR909')
```
```
// "coastline" @by eddyflux
// @version 1.0
samples('github:eddyflux/crate')
setcps(.75)
let chords = chord("<Bbm9 Fm9>/4").dict('ireal')
stack(
  stack( // DRUMS
    s("bd").struct("<[x*<1 2> [~@3 x]] x>"),
    s("~ [rim, sd:<2 3>]").room("<0 .2>"),
    n("[0 <1 3>]*<2!3 4>").s("hh"),
    s("rd:<1!3 2>*2").mask("<0 0 1 1>/16").gain(.5)
  ).bank('crate')
  .mask("<[0 1] 1 1 1>/16".early(.5))
  , // CHORDS
  chords.offset(-1).voicing().s("gm_epiano1:1")
  .phaser(4).room(.5)
  , // MELODY
  n("<0!3 1*2>").set(chords).mode("root:g2")
  .voicing().s("gm_acoustic_bass"),
  chords.n("[0 <4 3 <2 5>>*2](<3 5>,8)")
  .anchor("D5").voicing()
  .segment(4).clip(rand.range(.4,.8))
  .room(.75).shape(.3).delay(.25)
  .fm(sine.range(3,8).slow(8))
  .lpf(sine.range(500,1000).slow(8)).lpq(5)
  .rarely(ply("2")).chunk(4, fast(2))
  .gain(perlin.range(.6, .9))
  .mask("<0 1 1 0>/16")
)
.late("[0 .01]*4").late("[0 .01]*2").size(4)
```
</DOCS>

<RESPONSE_INSTRUCTIONS>
Generate valid Strudel pattern code using the Strudel.cc API.

Output format:
<CODE>
[your strudel pattern code here]
</CODE>

Requirements:
- Use ONLY valid Strudel functions.
- Put the code inside <CODE> tags
- You can pre-face with your creative freedom.
- The code must be executable in Strudel

Example outputs:
<CODE>
n("<0 2 1 3 2>*8")
.scale("<A1 D2>/4:minor:pentatonic")
.s("supersaw").lpf(300).lpenv("<4 3 2>*4")
</CODE>

The user will provide a music description. Respond with the Strudel code in <CODE> tags. 
</RESPONSE_INSTRUCTIONS>